<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>echo、tail和重定向符</title>
      <link href="/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/10.echo%E3%80%81tail%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%A6/"/>
      <url>/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/10.echo%E3%80%81tail%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h2><p>可以使用echo命令在命令行内输出指定内容<br>语法：echo 输出内容<br>无需选项，只有一个参数，表示要输出的内容，复杂内容可以用””包围<br><img src="/img/70.png" alt="70"></p><h2 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h2><p><img src="/img/71.png" alt="71"><br>本意是想，输出当前的工作路径，但是pwd被作为普通字符输出了。<br>我们可以通过将命令用反引号（通常也称之为飘号）将其包围<br>被反引号包围的内容，会被作为命令执行，而非普通字符<br><img src="/img/72.png" alt="72"></p><h2 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h2><p>重定向符：&gt;和&gt;&gt;</p><pre><code> &gt; ，将左侧命令的结果，覆盖写入到符号右侧指定的文件中&gt; &gt;，将左侧命令的结果，追加写入到符号右侧指定的文件中</code></pre><p><img src="/img/73.png" alt="73"></p><h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><p>使用tail命令，可以查看文件尾部内容，跟踪文件的最新更改，语法如下：<br>tail [-f -num] Linux路径<br>参数，Linux路径，表示被跟踪的文件路径<br>选项，-f，表示持续跟踪<br>选项, -num，表示，查看尾部多少行，不填默认10行<br><img src="/img/74.png" alt="74"></p><p><img src="/img/75.png" alt="75"></p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vi编辑器</title>
      <link href="/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/11.vi%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/11.vi%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>vi\vim是visual interface的简称, 是Linux中最经典的文本编辑器<br>同图形化界面中的 文本编辑器一样，vi是命令行下对文本文件进行编辑的绝佳选择。<br>vim 是 vi 的加强版本，兼容 vi 的所有指令，不仅能编辑文本，而且还具有 shell 程序编辑的功能，可以不同颜色的字体来辨别语法的正确性，极大方便了程序的设计和编辑性。</p><h2 id="vi-vim编辑器的三种工作模式"><a href="#vi-vim编辑器的三种工作模式" class="headerlink" title="vi\vim编辑器的三种工作模式"></a>vi\vim编辑器的三种工作模式</h2><p>命令模式（Command mode）<br>    命令模式下，所敲的按键编辑器都理解为命令，以命令驱动执行不同的功能。<br>    此模型下，不能自由进行文本编辑。<br>输入模式（Insert mode）<br>    也就是所谓的编辑模式、插入模式。<br>    此模式下，可以对文件内容进行自由编辑。<br>底线命令模式（Last line mode）<br>    以：开始，通常用于文件的保存、退出<br><img src="/img/76.png" alt="76"></p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>如果需要通过vi/vim编辑器编辑文件，请通过如下命令：<br>vi 文件路径 / vim 文件路径<br>vim兼容全部的vi功能，后续全部使用vim命令<br>如果文件路径表示的文件不存在，那么此命令会用于编辑新文件<br>如果文件路径表示的文件存在，那么此命令用于编辑已有文件</p><h4 id="命令模式快捷键"><a href="#命令模式快捷键" class="headerlink" title="命令模式快捷键"></a>命令模式快捷键</h4><p><img src="/img/77.png" alt="77"><br><img src="/img/78.png" alt="78"><br><img src="/img/79.png" alt="79"></p><h2 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h2><p><img src="/img/80.png" alt="80"></p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ls命令</title>
      <link href="/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/2.ls%E5%91%BD%E4%BB%A4/"/>
      <url>/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/2.ls%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>ls命令的作用是列出目录下的内容，语法细节如下：<br><img src="/img/29.png" alt="29"><br>-a -l -h 是可选的选项<br>Linux路径是此命令可选的参数<br>当不使用选项和参数，直接使用ls命令本体，表示：以平铺形式，列出当前工作目录下的内容</p><h2 id="Home目录和工作目录"><a href="#Home目录和工作目录" class="headerlink" title="Home目录和工作目录?"></a>Home目录和工作目录?</h2><p>直接输入ls命令，表示列出当前工作目录下的内容，当前工作目录是？<br>Linux系统的命令行终端，在启动的时候，默认会加载:<br>当前==登录用户的HOME目录作为当前工作目录==，所以ls命令列出的是HOME目录的内容<br>HOME目录：每个Linux操作用户在Linux系统的个人账户目录，==路径在：/home/用户名==<br>如Linux用户是itheima，其HOME目录是：/home/itheima</p><h2 id="a-l-h作用"><a href="#a-l-h作用" class="headerlink" title="-a -l -h作用"></a>-a -l -h作用</h2><ul><li><p>-a选项，表示：all的意思，即列出全部文件（包含隐藏的文件/文件夹）<br><img src="/img/30.png" alt="30"><br>图中以.开头的，表示是Linux系统的隐藏文件/文件夹（只要以.开头，就能自动隐藏）<br>只有通过-a选项，才能看到这些隐藏的文件/文件夹</p></li><li><p>-l选项，表示：以列表（竖向排列）的形式展示内容，并展示更多信息<br><img src="/img/31.png" alt="31"></p></li><li><p>-h选项:-h 表示以易于阅读的形式，列出文件大小，如K、M、G,-h选项必须要搭配 -l 一起使用<br><img src="/img/32.png" alt="32"></p></li></ul><p>-la,-lah同样也允许<br><img src="/img/33.png" alt="33"><br><img src="/img/34.png" alt="34"></p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目录切换相关命令(cd pwd)</title>
      <link href="/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/3.%E7%9B%AE%E5%BD%95%E5%88%87%E6%8D%A2%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4(cd%20pwd)/"/>
      <url>/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/3.%E7%9B%AE%E5%BD%95%E5%88%87%E6%8D%A2%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4(cd%20pwd)/</url>
      
        <content type="html"><![CDATA[<h2 id="cd-切换工作目录"><a href="#cd-切换工作目录" class="headerlink" title="cd 切换工作目录"></a>cd 切换工作目录</h2><p>当Linux终端（命令行）打开的时候，会默认以用户的HOME目录作为当前的工作目录<br>我们可以通过cd命令，更改当前所在的工作目录。<br>cd命令来自英文：Change Directory<br>语法：<img src="/img/35.png" alt="35"><br>cd命令无需选项，只有参数，表示要切换到哪个目录下<br>cd命令直接执行，不写参数，表示回到用户的HOME目录</p><p><img src="/img/36.png" alt="36"></p><h2 id="pwd-查看当前工作目录"><a href="#pwd-查看当前工作目录" class="headerlink" title="pwd 查看当前工作目录"></a>pwd 查看当前工作目录</h2><p>通过ls来验证当前的工作目录，其实是不恰当的。<br>我们可以通过pwd命令，来查看当前所在的工作目录。<br>pwd命令来自：Print Work Directory<br>语法：pwd<br>pwd命令，无选项，无参数，直接输入pwd即可<br><img src="/img/37.png" alt="37"></p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于命令选项的说明</title>
      <link href="/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/12.%E5%85%B3%E4%BA%8E%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9%E7%9A%84%E8%AF%B4%E6%98%8E/"/>
      <url>/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/12.%E5%85%B3%E4%BA%8E%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9%E7%9A%84%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>我们学习的一系列Linux命令，它们所拥有的选项都是非常多的。<br>比如，简单的ls命令就有：<br>-a -A -b -c -C -d -D -f -F -g -G -h -H -i -I -k -l -L -m -n -N -o -p -q -Q -r-R -s -S -t -T -u -U -v -w -x -X -1<br>等选项，可以发现选项是极其多的。</p><h2 id="查看命令帮助和手册"><a href="#查看命令帮助和手册" class="headerlink" title="查看命令帮助和手册"></a>查看命令帮助和手册</h2><p>任何命令都支持：—help 选项， 可以通过这个选项，查看命令的帮助。<br>如：ls —help， 会列出ls命令的帮助文档</p><p>如果想要查看命令的详细手册，可以通过man（manual， 手册）命令查看<br>比如：<br>man ls，就是查看ls命令的详细手册<br>man cd，就是查看cd命令的详细手册</p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件操作命令part1(touch、cat、more）</title>
      <link href="/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/6.%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4part1(touch%E3%80%81cat%E3%80%81more%EF%BC%89/"/>
      <url>/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/6.%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4part1(touch%E3%80%81cat%E3%80%81more%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="touch-创建文件"><a href="#touch-创建文件" class="headerlink" title="touch 创建文件"></a>touch 创建文件</h2><p>可以通过touch命令创建文件<br>语法：<img src="/img/45.png" alt="45"><br>touch命令无选项，参数必填，表示要创建的文件路径，相对、绝对、特殊路径符均可以使用<br><img src="/img/46.png" alt="46"></p><h2 id="cat命令-查看文件内容"><a href="#cat命令-查看文件内容" class="headerlink" title="cat命令 查看文件内容"></a>cat命令 查看文件内容</h2><p>准备好文件内容后，可以通过cat查看内容。<br>语法：<img src="/img/47.png" alt="47"><br>cat同样没有选项，只有必填参数，参数表示：被查看的文件路径，相对、绝对、特殊路径符都可以使用<br><img src="/img/48.png" alt="48"></p><h2 id="more命令查看文件内容"><a href="#more命令查看文件内容" class="headerlink" title="more命令查看文件内容"></a>more命令查看文件内容</h2><p>more命令同样可以查看文件内容，同cat不同的是：<br>cat是直接将内容全部显示出来<br>more支持翻页，如果文件内容过多，可以一页页的展示<br>语法：<img src="/img/49.img" alt="49"><br>同样没有选项，只有必填参数，参数表示：被查看的文件路径，相对、绝对、特殊路径符都可以使用<br>在查看的过程中，通过空格翻页<br>通过q退出查看</p><p><img src="/img/50.png" alt="50"><br><img src="/img/51.png" alt="51"></p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件操作命令part2(cp、mv、rm）</title>
      <link href="/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/7.%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4part2(cp%E3%80%81mv%E3%80%81rm%EF%BC%89/"/>
      <url>/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/7.%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4part2(cp%E3%80%81mv%E3%80%81rm%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="cp命令复制文件文件夹"><a href="#cp命令复制文件文件夹" class="headerlink" title="cp命令复制文件文件夹"></a>cp命令复制文件文件夹</h2><p>cp命令可以用于复制文件\文件夹，cp命令来自英文单词：copy<br>语法：<img src="/img/52.png" alt="52"><br>-r选项，可选，用于复制文件夹使用，表示递归<br>参数1，Linux路径，表示被复制的文件或文件夹<br>参数2，Linux路径，表示要复制去的地方<br><img src="/img/53.png" alt="53"><br><img src="/img/54.png" alt="54"></p><h2 id="mv移动文件或文件夹"><a href="#mv移动文件或文件夹" class="headerlink" title="mv移动文件或文件夹"></a>mv移动文件或文件夹</h2><p>mv命令可以用于移动文件\文件夹，mv命令来自英文单词：move<br>语法：<img src="/img/55.png" alt="55"><br>参数1，Linux路径，表示被移动的文件或文件夹<br>参数2，Linux路径，表示要移动去的地方，如果目标不存在，则进行改名，确保目标存在<br><img src="/img/56.png" alt="56"></p><h2 id="rm删除文件、文件夹"><a href="#rm删除文件、文件夹" class="headerlink" title="rm删除文件、文件夹"></a>rm删除文件、文件夹</h2><p>rm命令可用于删除文件、文件夹<br>rm命令来自英文单词：remove<br>语法：<img src="/img/57.png" alt="57"><br>同cp命令一样，-r选项用于删除文件夹<br>-f表示force，强制删除（不会弹出提示确认信息）<br>普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示<br>所以一般普通用户用不到-f选项<br>参数1、参数2、……、参数N 表示要删除的文件或文件夹路径，按照空格隔开<br><img src="/img/58.png" alt="58"><br>演示强制删除，-f选项<br>可以通过 su - root，并输入密码123456临时切换到root用户体验<br>通过输入exit命令，退回普通用户。<br><img src="/img/59.png" alt="59"></p><h3 id="rm删除文件、文件夹-通配符"><a href="#rm删除文件、文件夹-通配符" class="headerlink" title="rm删除文件、文件夹 - 通配符"></a>rm删除文件、文件夹 - 通配符</h3><p>rm命令支持通配符 <em>，用来做模糊匹配<br>符号</em> 表示通配符，即匹配任意内容（包含空），示例：<br>test<em>，表示匹配任何以test开头的内容</em>test，表示匹配任何以test结尾的内容<br><em>test</em>，表示匹配任何包含test的内容<br><img src="/img/60.png" alt="60"></p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建目录命令(mkdir)</title>
      <link href="/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/5.%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95%E5%91%BD%E4%BB%A4(mkdir)/"/>
      <url>/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/5.%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95%E5%91%BD%E4%BB%A4(mkdir)/</url>
      
        <content type="html"><![CDATA[<p>通过mkdir命令可以创建新的目录（文件夹）<br>mkdir来自英文：Make Directory<br>语法：<img src="/img/42.png" alt="42"><br>参数必填，表示Linux路径，即要创建的文件夹的路径，相对路径或绝对路径均可<br>-p选项可选，表示自动创建不存在的父目录，适用于创建连续多层级的目录<br><img src="/img/43.png" alt="43"></p><p>mkdir -p 选项:<br>如果想要一次性创建多个层级的目录，会报错，因为上级目录itcast和good并不存在，所以无法创建666目录。<br>可以通过-p选项，将一整个链条都创建完成。<br><img src="/img/44.png" alt="44"></p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找命令(which、find）</title>
      <link href="/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/8.%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4(which%E3%80%81find%EF%BC%89/"/>
      <url>/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/8.%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4(which%E3%80%81find%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h2><p>我们在前面学习的Linux命令，其实它们的本体就是一个个的二进制可执行程序。<br>和Windows系统中的.exe文件，是一个意思。<br>我们可以通过which命令，查看所使用的一系列命令的程序文件存放在哪里<br>语法：which 要查找的命令<br><img src="/img/61.png" alt="61"></p><h2 id="find命令-按文件名查找文件"><a href="#find命令-按文件名查找文件" class="headerlink" title="find命令 - 按文件名查找文件"></a>find命令 - 按文件名查找文件</h2><p>find 起始路径 -name “被查找文件名”<br><img src="/img/62.png" alt="62"><br>被查找文件名，支持使用通配符 <em> 来做模糊查询。<br>符号</em> 表示通配符，即匹配任意内容（包含空），示例：<br>test<em>，表示匹配任何以test开头的内容</em>test，表示匹配任何以test结尾的内容<br><em>test</em>，表示匹配任何包含test的内容<br>基于通配符的含义，可以结合find命令做文件的模糊查询。<br><img src="/img/63.png" alt="63"></p><h2 id="find命令-按文件大小查找文件"><a href="#find命令-按文件大小查找文件" class="headerlink" title="find命令 - 按文件大小查找文件"></a>find命令 - 按文件大小查找文件</h2><p>find 起始路径 -size +|-n[KMG]<br>+、- 表示大于和小于<br>n表示大小数字<br>kMG表示大小单位，k(小写字母)表示kb，M表示MB，G表示GB</p><p>示例：<br>查找小于10KB的文件： find / -size -10k<br>查找大于100MB的文件：find / -size +100M<br>查找大于1GB的文件：find / -size +1G</p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grep、wc和管道符</title>
      <link href="/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/9.grep%E3%80%81wc%E5%92%8C%E7%AE%A1%E9%81%93%E7%AC%A6/"/>
      <url>/2026/02/10/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/9.grep%E3%80%81wc%E5%92%8C%E7%AE%A1%E9%81%93%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><p>可以通过grep命令，从文件中通过关键字过滤文件行。<br>语法：grep [-n] 关键字 文件路径<br>选项-n，可选，表示在结果中显示匹配的行的行号。<br>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来<br>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口<br><img src="/img/64.png" alt="64"></p><h2 id="wc命令做数量统计"><a href="#wc命令做数量统计" class="headerlink" title="wc命令做数量统计"></a>wc命令做数量统计</h2><p>可以通过wc命令统计文件的行数、单词数量等<br>语法：wc [-c -m -l -w] 文件路径<br>选项，-c，统计bytes数量<br>选项，-m，统计字符数量<br>选项，-l，统计行数<br>选项，-w，统计单词数量<br>参数，文件路径，被统计的文件，可作为内容输入端口<br><img src="/img/65.png" alt="65"></p><h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h2><p>管道符的含义是：将管道符左边命令的结果，作为右边命令的输入<br><img src="/img/66.png" alt="66"><br><img src="/img/67.png" alt="67"><br><img src="/img/68.png" alt="68"><br>嵌套使用:<br><img src="/img/69.png" alt="69"></p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>程序运行在操作系统中，是被操作系统所管理的。<br>为管理运行的程序，每一个程序在运行的时候，便被操作系统注册为系统中的一个：进程<br>并会为每一个进程都分配一个独有的：进程ID（进程号）</p><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><p>可以通过ps命令查看Linux系统中的进程信息<br>语法：ps [-e -f]<br>选项：-e，显示出全部的进程<br>选项：-f，以完全格式化的形式展示信息（展示全部信息）<br>一般来说，固定用法就是： ps -ef 列出全部进程的全部信息<br>![[Pasted image 20260118160436.png]]<br>从左到右分别是：<br>UID：进程所属的用户ID<br>PID：进程的进程号ID<br>PPID：进程的父ID（启动此进程的其它进程）<br>C：此进程的CPU占用率（百分比）<br>STIME：进程的启动时间<br>TTY：启动此进程的终端序号，如显示?，表示非终端启动<br>TIME：进程占用CPU的时间<br>CMD：进程对应的名称或启动路径或启动命令</p><h3 id="查看指定进程"><a href="#查看指定进程" class="headerlink" title="查看指定进程"></a>查看指定进程</h3><p>在FinalShell中，执行命令：tail，可以看到，此命令一直阻塞在那里<br>在FinalShell中，复制一个标签页，执行：ps -ef 找出tail这个程序的进程信息<br>问题：是否会发现，列出的信息太多，无法准确的找到或很麻烦怎么办？<br>我们可以使用管道符配合grep来进行过滤，如：<br>ps -ef | grep tail，即可准确的找到tail命令的信息<br>![[Pasted image 20260118160650.png]]<br>过滤不仅仅过滤名称，进程号，用户ID等等，都可以被grep过滤哦<br>如：ps -ef | grep 30001，过滤带有30001关键字的进程信息（一般指代过滤30001进程号）</p><h3 id="关闭进程"><a href="#关闭进程" class="headerlink" title="关闭进程"></a>关闭进程</h3><p>Windows系统中，可以通过任务管理器选择进程后，点击结束进程从而关闭它。<br>同样，在Linux中，可以通过kill命令关闭进程。<br>语法：kill [-9] 进程ID<br>选项：-9，表示强制关闭进程。不使用此选项会向进程发送信号要求其关闭，但是否关闭看进程自身的处理机制。<br>![[Pasted image 20260118160809.png]]<br>![[Pasted image 20260118160931.png]]<br>![[Pasted image 20260118160942.png]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E8%BD%AF%E9%93%BE%E6%8E%A5/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E8%BD%AF%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="ln命令创建软连接"><a href="#ln命令创建软连接" class="headerlink" title="ln命令创建软连接"></a>ln命令创建软连接</h2><p>在系统中创建软链接，可以将文件、文件夹链接到其它位置。<br>类似Windows系统中的《快捷方式》<br>语法：ln -s 参数1 参数2<br>-s选项，创建软连接<br>参数1：被链接的文件或文件夹<br>参数2：要链接去的目的地<br>实例：<br>ln -s /etc/yum.conf ~/yum.conf<br>ln -s /etc/yum ~/yum<br>![[Pasted image 20260118125408.png]]<br>![[Pasted image 20260118125530.png]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux系统的应用商店"><a href="#Linux系统的应用商店" class="headerlink" title="Linux系统的应用商店"></a>Linux系统的应用商店</h2><p>操作系统安装软件有许多种方式，一般分为：<br>下载安装包自行安装<br>如win系统使用exe文件、msi文件等<br>如mac系统使用dmg文件、pkg文件等<br>系统的应用商店内安装<br>如win系统有Microsoft Store商店<br>如mac系统有AppStore商店</p><p>Linux系统同样支持这两种方式，我们首先，先来学习使用：Linux命令行内的”应用商店”，yum命令安装软件</p><h2 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h2><p>yum：RPM包软件管理器，用于自动化安装配置Linux软件，并可以自动解决依赖问题。<br>语法：yum [-y]  [install |  remove  | search]  软件名称<br>选项：-y，自动确认，无需手动确认安装或卸载过程<br>install：安装<br>remove：卸载<br>search：搜索<br>yum命令需要root权限哦，可以su切换到root，或使用sudo提权。<br>yum命令需要联网<br>![[Pasted image 20260118122732.png]]</p><h2 id="apt命令-Ubuntu系统"><a href="#apt命令-Ubuntu系统" class="headerlink" title="apt命令(Ubuntu系统)"></a>apt命令(Ubuntu系统)</h2><p>apt [-y]  [install |  remove  | search]  软件名称<br>![[Pasted image 20260118122947.png]]<br>![[Pasted image 20260118123014.png]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E7%AB%AF%E5%8F%A3/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E7%AB%AF%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>端口，是设备与外界通讯交流的出入口。端口可以分为：物理端口和虚拟端口两类<br>物理端口：又可称之为接口，是可见的端口，如USB接口，RJ45网口，HDMI端口等<br>虚拟端口：是指计算机内部的端口，是不可见的，是用来操作系统和外部进行交互使用的</p><h3 id="端口（虚拟）"><a href="#端口（虚拟）" class="headerlink" title="端口（虚拟）"></a>端口（虚拟）</h3><p>![[Pasted image 20260118153922.png]]<br>Linux系统是一个超大号小区，可以支持65535个端口，这6万多个端口分为3类进行使用：<br>公认端口：1~1023，通常用于一些系统内置或知名程序的预留使用，如SSH服务的22端口，HTTPS服务的443端口，非特殊需要，不要占用这个范围的端口<br>注册端口：1024~49151，通常可以随意使用，用于松散的绑定一些程序\服务<br>动态端口：49152~65535，通常不会固定绑定程序，而是当程序对外进行网络链接时，用于临时使用。<br>![[Pasted image 20260118154017.png]]<br>如图中，计算机A的微信连接计算机B的微信，A使用的50001即动态端口，临时找一个端口作为出口<br>计算机B的微信使用端口5678，即注册端口，长期绑定此端口等待别人连接</p><h2 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h2><p>可以通过Linux命令去查看端口的占用情况<br>使用nmap命令，安装nmap：yum -y install nmap<br>语法：nmap 被查看的IP地址<br>![[Pasted image 20260118154657.png]]</p><p>可以通过netstat命令，查看指定端口的占用情况<br>语法：netstat -anp | grep 端口号，安装netstat：yum -y install net-tools<br>![[Pasted image 20260118154550.png]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>在讲解which命令的时候，我们知道使用的一系列命令其实本质上就是一个个的可执行程序。<br>比如，cd命令的本体就是：/usr/bin/cd 这个程序文件。<br>我们是否会有疑问，为何无论当前工作目录在哪里，都能执行：/usr/bin/cd这个程序呢？<br>这就是环境变量的作用啦。</p><p>环境变量是操作系统（Windows、Linux、Mac）在运行的时候，记录的一些关键性信息，用以辅助系统运行。<br>在Linux系统中执行：env命令即可查看当前系统中记录的环境变量<br>环境变量是一种KeyValue型结构，即名称和值，如下图：<br>![[Pasted image 20260118171552.png]]</p><h2 id="环境变量：PATH"><a href="#环境变量：PATH" class="headerlink" title="环境变量：PATH"></a>环境变量：PATH</h2><p>在前面提出的问题中，我们说无论当前工作目录是什么，都能执行/usr/bin/cd这个程序，这个就是借助环境变量中：PATH这个项目的值来做到的。<br>![[Pasted image 20260118171713.png]]<br>PATH记录了系统执行任何命令的搜索路径<br>当执行任何命令，都会按照顺序，从上述路径中搜索要执行的程序的本体<br>比如执行cd命令，就从第二个目录/usr/bin中搜索到了cd命令，并执行</p><h2 id="符号"><a href="#符号" class="headerlink" title="$符号"></a>$符号</h2><p>在Linux系统中，$符号被用于取”变量”的值。<br>环境变量记录的信息，除了给操作系统自己使用外，如果我们想要取用，也可以使用。<br>取得环境变量的值就可以通过语法：$环境变量名  来取得<br>比如： echo $PATH<br>就可以取得PATH这个环境变量的值，并通过echo语句输出出来。<br>![[Pasted image 20260118171913.png]]<br>又或者：echo ${PATH}ABC<br>![[Pasted image 20260118172018.png]]、<br>当和其它内容混合在一起的时候，可以通过{}来标注取的变量是谁</p><h2 id="自行设置环境变量"><a href="#自行设置环境变量" class="headerlink" title="自行设置环境变量"></a>自行设置环境变量</h2><p>Linux环境变量可以用户自行设置，其中分为：<br>临时设置，语法：export 变量名=变量值<br>![[Pasted image 20260118172144.png]]<br>永久生效<br>针对当前用户生效，配置在当前用户的：    ~/.bashrc文件中<br>![[Pasted image 20260118172537.png]]<br>针对所有用户生效，配置在系统的：    /etc/profile文件中<br>并通过语法：source 配置文件，进行立刻生效，或重新登录FinalShell生效<br>![[Pasted image 20260118172852.png]]</p><h2 id="自定义环境变量PATH"><a href="#自定义环境变量PATH" class="headerlink" title="自定义环境变量PATH"></a>自定义环境变量PATH</h2><p>环境变量PATH这个项目里面记录了系统执行命令的搜索路径。<br>这些搜索路径我们也可以自行添加到PATH中去。<br>测试：<br>在当前HOME目录内创建文件夹，myenv，在文件夹内创建文件mkhaha<br>通过vim编辑器，在mkhaha文件内填入：echo 哈哈哈哈哈<br>完成上述操作后，随意切换工作目录，执行mkhaha命令尝试一下，会发现无法执行<br>![[Pasted image 20260118174459.png]]<br>修改PATH的值<br>临时修改PATH：export PATH=$PATH:/home/itheima/myenv，再次执行mkhaha，无论在哪里都能执行了<br>或将export PATH=$PATH:/home/itheima/myenv，填入用户环境变量文件或系统环境变量文件中去<br>![[Pasted image 20260118175254.png]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E5%8C%BA/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h2><p>![[Pasted image 20260118130627.png]]</p><p>date<br>![[Pasted image 20260118130741.png]]<br>按照2026-01-18的格式显示日期<br>![[Pasted image 20260118131054.png]]<br>按照2026-01-18 xx:xx:xx的格式显示日期<br>![[Pasted image 20260118131341.png]]</p><p>-d选项，可以按照给定的字符串显示日期，一般用于日期计算<br>![[Pasted image 20260118131411.png]]<br>其中支持的时间标记为：<br>year年<br>month月<br>day天<br>hour小时<br>minute分钟<br>second秒<br>-d选项可以和 格式化字符串配合一起使用哦<br>![[Pasted image 20260118131500.png]]</p><h2 id="修改Linux时区"><a href="#修改Linux时区" class="headerlink" title="修改Linux时区"></a>修改Linux时区</h2><p>通过date查看的日期时间是不准确的，这是因为：系统默认时区非中国的东八区。<br>![[Pasted image 20260118134303.png]]<br>![[Pasted image 20260118134452.png]]</p><h2 id="ntp程序"><a href="#ntp程序" class="headerlink" title="ntp程序"></a>ntp程序</h2><p>我们可以通过ntp程序自动校准系统时间<br>安装ntp：yum -y install ntp<br>启动并设置开机自启：<br>systemctl start ntpd<br>systemctl enable ntpd<br>当ntpd启动后会定期的帮助我们联网校准系统的时间</p><p>也可以手动校准（需root权限）：ntpdate -u ntp.aliyun.com<br>通过阿里云提供的服务网址配合ntpdate（安装ntp后会附带这个命令）命令自动校准</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E5%90%84%E7%B1%BB%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%89/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E5%90%84%E7%B1%BB%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="ctrl-c-强制停止"><a href="#ctrl-c-强制停止" class="headerlink" title="ctrl + c 强制停止"></a>ctrl + c 强制停止</h2><p>Linux某些程序的运行，如果想要强制停止它，可以使用快捷键ctrl + c<br>![[Pasted image 20260118115537.png]]<br>命令输入错误，也可以通过快捷键ctrl + c，退出当前输入，重新输入<br>![[Pasted image 20260118115624.png]]</p><h2 id="ctrl-d-退出或登出"><a href="#ctrl-d-退出或登出" class="headerlink" title="ctrl + d 退出或登出"></a>ctrl + d 退出或登出</h2><p>可以通过快捷键：ctrl + d，退出账户的登录<br>![[Pasted image 20260118115730.png]]<br>或者退出某些特定程序的专属页面 ps：不能用于退出vi/vim<br>![[Pasted image 20260118115813.png]]</p><h2 id="历史命令搜索"><a href="#历史命令搜索" class="headerlink" title="历史命令搜索"></a>历史命令搜索</h2><h3 id="可以通过history命令，查看历史输入过的命令"><a href="#可以通过history命令，查看历史输入过的命令" class="headerlink" title="可以通过history命令，查看历史输入过的命令"></a>可以通过history命令，查看历史输入过的命令</h3><p>![[Pasted image 20260118115911.png]]</p><h3 id="可以通过：-命令前缀，自动执行上一次匹配前缀的命令"><a href="#可以通过：-命令前缀，自动执行上一次匹配前缀的命令" class="headerlink" title="可以通过：!命令前缀，自动执行上一次匹配前缀的命令"></a>可以通过：!命令前缀，自动执行上一次匹配前缀的命令</h3><p>![[Pasted image 20260118120507.png]]<br>它会从下往上匹配历史命令中第一个以p开头的命令并执行</p><h3 id="可以通过快捷键：ctrl-r，输入内容去匹配历史命令"><a href="#可以通过快捷键：ctrl-r，输入内容去匹配历史命令" class="headerlink" title="可以通过快捷键：ctrl + r，输入内容去匹配历史命令"></a>可以通过快捷键：ctrl + r，输入内容去匹配历史命令</h3><p>如果搜索到的内容是你需要的，那么：<br>回车键可以直接执行<br>键盘左右键，可以得到此命令（不执行）<br>![[Pasted image 20260118120712.png]]</p><h2 id="光标移动快捷键"><a href="#光标移动快捷键" class="headerlink" title="光标移动快捷键"></a>光标移动快捷键</h2><p>ctrl + a，跳到命令开头<br>ctrl + e，跳到命令结尾<br>ctrl + 键盘左键，向左跳一个单词<br>ctrl + 键盘右键，向右跳一个单词</p><h2 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h2><p>通过快捷键ctrl + l，可以清空终端内容<br>或通过命令clear得到同样效果</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E5%8E%8B%E7%BC%A9%E3%80%81%E8%A7%A3%E5%8E%8B/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E5%8E%8B%E7%BC%A9%E3%80%81%E8%A7%A3%E5%8E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="压缩格式"><a href="#压缩格式" class="headerlink" title="压缩格式"></a>压缩格式</h2><p>zip格式：Linux、Windows、MacOS，常用<br>7zip：Windows系统常用<br>rar：Windows系统常用<br>tar：Linux、MacOS常用<br>gzip：Linux、MacOS常用</p><h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h2><p>Linux和Mac系统常用有2种压缩格式，后缀名分别是：<br>.tar，称之为tarball，归档文件，即简单的将文件组装到一个.tar的文件内，并没有太多文件体积的减少，仅仅是简单的封装<br>.gz，也常见为.tar.gz，gzip格式压缩文件，即使用gzip压缩算法将文件压缩到一个文件内，可以极大的减少压缩后的体积<br>针对这两种格式，使用tar命令均可以进行压缩和解压缩的操作<br>![[Pasted image 20260118182836.png]]</p><h3 id="tar-命令压缩"><a href="#tar-命令压缩" class="headerlink" title="tar 命令压缩"></a>tar 命令压缩</h3><p>tar的常用组合为：<br>tar -cvf test.tar 1.txt 2.txt 3.txt<br>将1.txt 2.txt 3.txt 压缩到test.tar文件内<br>tar -zcvf test.tar.gz 1.txt 2.txt 3.txt<br>将1.txt 2.txt 3.txt 压缩到test.tar.gz文件内，使用gzip模式<br>注意：<br>-z选项如果使用的话，一般处于选项位第一个<br>-f选项，必须在选项位最后一个<br>![[Pasted image 20260118183222.png]]<br>![[Pasted image 20260118183252.png]]</p><h3 id="tar-解压"><a href="#tar-解压" class="headerlink" title="tar 解压"></a>tar 解压</h3><p>常用的tar解压组合有<br>tar -xvf test.tar<br>解压test.tar，将文件解压至当前目录<br>tar -xvf test.tar -C /home/zedwarf<br>解压test.tar，将文件解压至指定目录（/home/zedwarf）<br>tar -zxvf test.tar.gz -C /home/zedwarf<br>以Gzip模式解压test.tar.gz，将文件解压至指定目录（/home/zedwarf）</p><p>注意：<br>-f选项，必须在选项组合体的最后一位<br>-z选项，建议在开头位置<br>-C选项单独使用，和解压所需的其它参数分开</p><h2 id="zip命令"><a href="#zip命令" class="headerlink" title="zip命令"></a>zip命令</h2><h3 id="zip-命令压缩文件"><a href="#zip-命令压缩文件" class="headerlink" title="zip 命令压缩文件"></a>zip 命令压缩文件</h3><p>可以使用zip命令，压缩文件为zip压缩包<br>语法：：zip [-r] 参数1 参数2 参数3 ……参数N<br>-r，被压缩的包含文件夹的时候，需要使用-r选项，和rm、cp等命令的-r效果一致<br>示例：<br>zip test.zip a.txt b.txt c.txt<br>将a.txt b.txt c.txt 压缩到test.zip文件内<br>zip -r test.zip test itheima a.txt<br>将test、itheima两个文件夹和a.txt文件，压缩到test.zip文件内</p><h3 id="unzip-命令解压文件"><a href="#unzip-命令解压文件" class="headerlink" title="unzip 命令解压文件"></a>unzip 命令解压文件</h3><p>使用unzip命令，可以方便的解压zip压缩包<br>语法：unzip [-d] 参数<br>-d，指定要解压去的位置，同tar的-C选项<br>参数，被解压的zip压缩包文件<br>示例：<br>unzip test.zip，将test.zip解压到当前目录<br>unzip test.zip -d /home/zedwarf，将test.zip解压到指定文件夹内（/home/zedwarf）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E4%B8%BB%E6%9C%BA%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E4%B8%BB%E6%9C%BA%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="查看系统资源占用"><a href="#查看系统资源占用" class="headerlink" title="查看系统资源占用"></a>查看系统资源占用</h2><p>可以通过top命令查看CPU、内存使用情况，类似Windows的任务管理器<br> 默认每5秒刷新一次，语法：直接输入top即可，按q或ctrl + c退出 ![[Pasted image 20260118164514.png]]<br>![[Pasted image 20260118164548.png]]<br>![[Pasted image 20260118164603.png]]</p><h3 id="top命令选项"><a href="#top命令选项" class="headerlink" title="top命令选项"></a>top命令选项</h3><p>![[Pasted image 20260118164701.png]]<br>![[Pasted image 20260118164742.png]]</p><h2 id="磁盘信息监控"><a href="#磁盘信息监控" class="headerlink" title="磁盘信息监控"></a>磁盘信息监控</h2><p>使用df命令，可以查看硬盘的使用情况<br>语法：df [-h]<br>选项：-h，以更加人性化的单位显示<br>![[Pasted image 20260118164832.png]]</p><p>可以使用iostat查看CPU、磁盘的相关信息<br>语法：iostat [-x] [num1] [num2]<br>选项：-x，显示更多信息<br>num1：数字，刷新间隔，num2：数字，刷新几次<br>![[Pasted image 20260118164906.png]]<br>tps：该设备每秒的传输次数（Indicate the number of transfers per second that were issued to the device.）。”一次传输”意思是”一次I/O请求”。多个逻辑请求可能会被合并为”一次I/O请求”。”一次传输”请求的大小是未知的。<br>使用iostat的-x选项，可以显示更多信息<br>![[Pasted image 20260118164939.png]]<br>rrqm/s：    每秒这个设备相关的读取请求有多少被Merge了（当系统调用需要读取数据的时候，VFS将请求发到各个FS，如果FS发现不同的读取请求读取的是相同Block的数据，FS会将这个请求合并Merge, 提高IO利用率, 避免重复调用）；<br>wrqm/s：    每秒这个设备相关的写入请求有多少被Merge了。<br>rsec/s：    每秒读取的扇区数；sectors<br>wsec/：    每秒写入的扇区数。<br>rKB/s：    每秒发送到设备的读取请求数<br>wKB/s：    每秒发送到设备的写入请求数<br>avgrq-sz     平均请求扇区的大小<br>avgqu-sz     平均请求队列的长度。毫无疑问，队列长度越短越好。<br>await：      每一个IO请求的处理的平均时间（单位是微秒毫秒）。<br>svctm        表示平均每次设备I/O操作的服务时间（以毫秒为单位）<br>%util：     磁盘利用率</p><h2 id="网络状态监控"><a href="#网络状态监控" class="headerlink" title="网络状态监控"></a>网络状态监控</h2><p>可以使用sar命令查看网络的相关统计（sar命令非常复杂，这里仅简单用于统计网络）<br>语法：sar -n DEV num1 num2<br>选项：-n，查看网络，DEV表示查看网络接口<br>num1：刷新间隔（不填就查看一次结束），num2：查看次数（不填无限次数）<br>![[Pasted image 20260118165109.png]]<br>信息解读：<br>IFACE 本地网卡接口的名称<br>rxpck/s 每秒钟接受的数据包<br>txpck/s 每秒钟发送的数据包<br>rxKB/S 每秒钟接受的数据包大小，单位为KB<br>txKB/S 每秒钟发送的数据包大小，单位为KB<br>rxcmp/s 每秒钟接受的压缩数据包<br>txcmp/s 每秒钟发送的压缩包<br>rxmcst/s 每秒钟接收的多播数据包</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><p>可以通过ping命令，检查指定的网络服务器是否是可联通状态<br>语法：ping [-c num] ip或主机名<br>选项：-c，检查的次数，不使用-c选项，将无限次数持续检查<br>参数：ip或主机名，被检查的服务器的ip地址或主机名地址<br>![[Pasted image 20260118150137.png]]</p><h2 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h2><p>wget是非交互式的文件下载器，可以在命令行内下载网络文件<br>语法：wget [-b] url<br>选项：-b，可选，后台下载，会将日志写入到当前工作目录的wget-log文件<br>参数：url，下载链接<br>通过tail命令可以监控后台下载进度：tail -f wget-log<br>注意：无论下载是否完成，都会生成要下载的文件，如果下载未完成，请及时清理未完成的不可用文件。<br>![[Pasted image 20260118150931.png]]</p><h2 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h2><p>curl可以发送http网络请求，可用于：下载文件、获取信息等<br>语法：curl [-O] url<br>选项：-O，用于下载文件，当url是下载链接时，可以使用此选项保存文件<br>参数：url，要发起请求的网络地址<br>![[Pasted image 20260118150802.png]]<br>![[Pasted image 20260118150846.png]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/systemctl/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/systemctl/</url>
      
        <content type="html"><![CDATA[<h2 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h2><p>Linux系统很多软件（内置或第三方）均支持使用systemctl命令控制：启动、停止、开机自启<br>能够被systemctl管理的软件，一般也称之为：服务<br>语法：systemctl  start|stop|status|enable|disable  服务名<br>系统内置的服务比较多，比如：<br>NetworkManager，主网络服务<br>network，副网络服务<br>firewalld，防火墙服务<br>sshd，ssh服务（FinalShell远程登录Linux使用的就是这个服务）<br>![[Pasted image 20260118124057.png]]</p><p>除了内置的服务以外，部分第三方软件安装后也可以以systemctl进行控制。<br>yum install -y ntp，安装ntp软件<br>可以通过ntpd服务名，配合systemctl进行控制<br>yum install -y httpd，安装apache服务器软件<br>可以通过httpd服务名，配合systemctl进行控制<br>部分软件安装后没有自动集成到systemctl中，我们可以手动添加。<br>![[Pasted image 20260118124317.png]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/Linux%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/Linux%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="通过FinalShell在Linux系统中进行上传、下载"><a href="#通过FinalShell在Linux系统中进行上传、下载" class="headerlink" title="通过FinalShell在Linux系统中进行上传、下载"></a>通过FinalShell在Linux系统中进行上传、下载</h2><p>我们可以通过FinalShell工具，方便的和虚拟机进行数据交换。<br>在FinalShell软件的下方窗体中，提供了Linux的文件系统视图，可以方便的：<br>浏览文件系统，找到合适的文件，右键点击下载，即可传输到本地电脑<br>浏览文件系统，找到合适的目录，将本地电脑的文件拓展进入，即可方便的上传数据到Linux中</p><h2 id="rz、sz命令"><a href="#rz、sz命令" class="headerlink" title="rz、sz命令"></a>rz、sz命令</h2><p>当然，除了通过FinalShell的下方窗体进行文件的传输以外，也可以通过rz、sz命令进行文件传输。<br>rz、sz命令需要安装，可以通过：yum -y install lrzsz，即可安装。<br>rz命令，进行上传，语法：直接输入rz即可<br>![[Pasted image 20260118181306.png]]<br>sz命令进行下载，语法：sz 要下载的文件<br>文件会自动下载到桌面的：fsdownload文件夹中。<br>注意，rz、sz命令需要终端软件支持才可正常运行<br>FinalShell、SecureCRT、XShell等常用终端软件均支持此操作</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/IP%E5%9C%B0%E5%9D%80%E3%80%81%E4%B8%BB%E6%9C%BA%E5%90%8D/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/IP%E5%9C%B0%E5%9D%80%E3%80%81%E4%B8%BB%E6%9C%BA%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>每一台联网的电脑都会有一个地址，用于和其它计算机进行通讯<br>IP地址主要有2个版本，V4版本和V6版本（V6很少用）<br>IPv4版本的地址格式是：a.b.c.d，其中abcd表示0~255的数字，如192.168.88.101就是一个标准的IP地址<br>可以通过命令：ifconfig，查看本机的ip地址，如无法使用ifconfig命令，可以安装：yum -y install net-tools</p><h3 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h3><p>127.0.0.1，这个IP地址用于指代本机<br>0.0.0.0，特殊IP地址<br>可以用于指代本机<br>可以在端口绑定中用来确定绑定关系<br>在一些IP地址限制中，表示所有IP的意思，如放行规则设置为0.0.0.0，表示允许任意IP访问</p><h2 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h2><p>每一台电脑除了对外联络地址（IP地址）以外，也可以有一个名字，称之为主机名<br>无论是Windows或Linux系统，都可以给系统设置主机名</p><h3 id="在Linux中修改主机名"><a href="#在Linux中修改主机名" class="headerlink" title="在Linux中修改主机名"></a>在Linux中修改主机名</h3><p>可以使用命令：hostname查看主机名<br>![[Pasted image 20260118140813.png]]<br>可以使用命令：hostnamectl set-hostname 主机名，修改主机名（需root）<br>![[Pasted image 20260118141024.png]]</p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>IP地址实在是难以记忆，有没有什么办法可以通过主机名或替代的字符地址去代替数字化的IP地址呢？<br>实际上，我们一直都是通过字符化的地址去访问服务器，很少指定IP地址<br>比如，我们在浏览器内打开：www.baidu.com，会打开百度的网址<br>其中，www.baidu.com，是百度的网址，我们称之为：域名<br>![[Pasted image 20260118141126.png]]</p><h3 id="配置主机名映射"><a href="#配置主机名映射" class="headerlink" title="配置主机名映射"></a>配置主机名映射</h3><p>比如，我们FinalShell是通过IP地址连接到的Linux服务器，那有没有可能通过域名（主机名）连接呢？<br>可以，我们只需要在Windows系统的：C:\Windows\System32\drivers\etc\hosts文件中配置记录即可</p><p>首先以管理员身份打开记事本然后找到![[Pasted image 20260118141445.png]]<br>在文档末尾输入你的IP地址 主机名即可</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E6%9D%83%E9%99%90%E7%AE%A1%E6%8E%A7/%E8%AE%A4%E7%9F%A5root%E7%94%A8%E6%88%B7/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E6%9D%83%E9%99%90%E7%AE%A1%E6%8E%A7/%E8%AE%A4%E7%9F%A5root%E7%94%A8%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="root用户（超级管理员-。"><a href="#root用户（超级管理员-。" class="headerlink" title="root用户（超级管理员)。"></a>root用户（超级管理员)。</h2><p>root用户拥有最大的系统操作权限，而普通用户在许多地方的权限是受限的。<br>•普通用户的权限，一般在其HOME目录内是不受限的<br>•一旦出了HOME目录，大多数地方，普通用户仅有只读和执行权限，无修改权限<br>![[Pasted image 20260117111044.png]]</p><h2 id="su和exit命令"><a href="#su和exit命令" class="headerlink" title="su和exit命令"></a>su和exit命令</h2><p>在前面，我们接触过su命令切换到root账户。<br>su命令就是用于账户切换的系统命令，其来源英文单词：SwitchUser<br>语法：su [-] 用户名<br>•-符号是可选的，表示是否在切换用户后加载环境变量，建议带上<br>•参数：用户名，表示要切换的用户，用户名也可以省略，省略表示切换到root<br>•切换用户后，可以通过exit命令退回上一个用户，也可以使用快捷键：ctrl + d<br>•使用普通用户，切换到其它用户需要输入密码，如切换到root用户<br>•使用root用户切换到其它用户，无需密码，可以直接切换<br>![[Pasted image 20260117111332.png]]</p><h2 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h2><p>在我们得知root密码的时候，可以通过su命令切换到root得到最大权限。<br>但是我们不建议长期使用root用户，避免带来系统损坏。<br>我们可以使用sudo命令，为普通的命令授权，临时以root身份执行。<br>语法：sudo 其他命令<br>•在其它命令之前，带上sudo，即可为这一条命令临时赋予root授权<br>•但是并不是所有的用户，都有权利使用sudo，我们需要为普通用户配置sudo认证</p><h3 id="为普通用户配置sudo认证"><a href="#为普通用户配置sudo认证" class="headerlink" title="为普通用户配置sudo认证"></a>为普通用户配置sudo认证</h3><p>•切换到root用户，执行visudo命令，会自动通过vi编辑器打开：/etc/sudoers<br>•在文件的最后添加：用户名 ALL=(ALL)  NOPASSWORD:ALL<br>•其中最后的NOPASSWD:ALL表示使用sudo命令，无需输入密码<br>•最后通过wq保存<br>•切换回普通用户<br>•执行的命令，均以root运行<br>![[Pasted image 20260117112558.png]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E6%9D%83%E9%99%90%E7%AE%A1%E6%8E%A7/%E7%94%A8%E6%88%B7%E3%80%81%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E6%9D%83%E9%99%90%E7%AE%A1%E6%8E%A7/%E7%94%A8%E6%88%B7%E3%80%81%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="用户、用户组"><a href="#用户、用户组" class="headerlink" title="用户、用户组"></a>用户、用户组</h2><p>Linux系统中可以：<br>•配置多个用户<br>•配置多个用户组<br>•用户可以加入多个用户组中</p><p>Linux中关于权限的管控级别有2个级别，分别是：<br>•针对用户的权限控制<br>•针对用户组的权限控制</p><h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><p>以下命令需root用户执行<br>•创建用户组<br>groupadd用户组名<br>•删除用户组<br>groupdel用户组名</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>以下命令需root用户执行<br>•创建用户<br>useradd [-g -d]用户名<br>•选项：-g指定用户的组，不指定-g，会创建同名组并自动加入，指定-g需要组已经存在，如已存在同名组，必须使用-g<br>•选项：-d指定用户HOME路径，不指定，HOME目录默认在：/home/用户名</p><p>•删除用户<br>userdel [-r]用户名<br>•选项：-r，删除用户的HOME目录，不使用-r，删除用户时，HOME目录保留</p><p>•查看用户所属组<br>id [用户名]<br>•参数：用户名，被查看的用户，如果不提供则查看自身</p><p>•修改用户所属组<br>usermod -aG用户组 用户名，将指定用户加入指定用户组<br>![[Pasted image 20260117115306.png]]</p><h2 id="getent"><a href="#getent" class="headerlink" title="getent"></a>getent</h2><p>使用getent命令，可以查看当前系统中有哪些用户<br>语法：getent passwd<br>![[Pasted image 20260117115514.png]]<br>共有7份信息，分别是：<br>用户名:密码(x):用户ID:组ID:描述信息(无用):HOME目录:执行终端(默认bash)</p><p>使用getent命令，同样可以查看当前系统中有哪些用户组<br>语法：getent group<br>![[Pasted image 20260117115610.png]]<br>包含3份信息，组名称:组认证(显示为x):组ID</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E6%9D%83%E9%99%90%E7%AE%A1%E6%8E%A7/%E6%9F%A5%E7%9C%8B%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E6%9D%83%E9%99%90%E7%AE%A1%E6%8E%A7/%E6%9F%A5%E7%9C%8B%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>通过ls -l可以以列表形式查看内容，并显示权限细节<br>![[Pasted image 20260117122103.png]]<br>•序号1，表示文件、文件夹的权限控制信息<br>•序号2，表示文件、文件夹所属用户<br>•序号3，表示文件、文件夹所属用户组</p><h2 id="认知权限信息"><a href="#认知权限信息" class="headerlink" title="认知权限信息"></a>认知权限信息</h2><p>让我们来解析一下序号1，权限细节<br>权限细节总共分为10个槽位<br>![[Pasted image 20260117122215.png]]<br>那么，rwx到底代表什么呢？<br>•r表示读权限<br>•w表示写权限<br>•x表示执行权限<br>针对文件、文件夹的不同，rwx的含义有细微差别<br>•r，针对文件可以查看文件内容<br>•针对文件夹，可以查看文件夹内容，如ls命令<br>•w，针对文件表示可以修改此文件<br>•针对文件夹，可以在文件夹内：创建、删除、改名等操作<br>•x，针对文件表示可以将文件作为程序执行<br>•针对文件夹，表示可以更改工作目录到此文件夹，即cd进入</p><p>![[Pasted image 20260117122326.png]]<br>对于boot它是一个文件夹,我们当前用户(zedwarf)对它的权限有r-x<br>![[Pasted image 20260117122603.png]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E6%9D%83%E9%99%90%E7%AE%A1%E6%8E%A7/%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6-%20chown/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E6%9D%83%E9%99%90%E7%AE%A1%E6%8E%A7/%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6-%20chown/</url>
      
        <content type="html"><![CDATA[<h2 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h2><p>使用chown命令，可以修改文件、文件夹的所属用户和用户组<br>普通用户无法修改所属为其它用户或组，所以此命令只适用于root用户执行<br>语法：chown [-R]  [用户]  [:]  [用户] 文件或文件夹<br>•选项，-R，同chmod，对文件夹内全部内容应用相同规则<br>•选项，用户，修改所属用户<br>•选项，用户组，修改所属用户组<br>•:用于分隔用户和用户组<br>示例：<br>•chown root hello.txt，将hello.txt所属用户修改为root<br>•chown :root hello.txt，将hello.txt所属用户组修改为root<br>•chown root:itheima hello.txt，将hello.txt所属用户修改为root，用户组修改为itheima<br>•chown -R root test，将文件夹test的所属用户修改为root并对文件夹内全部内容应用同样规则</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E6%9D%83%E9%99%90%E7%AE%A1%E6%8E%A7/%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6-%20chmod/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E6%9D%83%E9%99%90%E7%AE%A1%E6%8E%A7/%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6-%20chmod/</url>
      
        <content type="html"><![CDATA[<h2 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h2><p>我们可以使用chmod命令，修改文件、文件夹的权限信息。<br>注意，==只有文件、文件夹的所属用户或root用户可以修改==。<br>语法：chmod [-R] 权限 文件或文件夹<br>•选项：-R，对文件夹内的全部内容应用同样的操作<br>示例：<br>•chmod u=rwx,g=rx,o=x hello.txt，将文件权限修改为：rwxr-x—x<br>•其中：u表示user所属用户权限，g表示group组权限，o表示other其它用户权限<br>•chmod -Ru=rwx,g=rx,o=x test，将文件夹test以及文件夹内全部内容权限设置为：rwxr-x—x</p><h2 id="权限的数字序号"><a href="#权限的数字序号" class="headerlink" title="权限的数字序号"></a>权限的数字序号</h2><p>权限可以用3位数字来代表，第一位数字表示用户权限，第二位表示用户组权限，第三位表示其它用户权限。<br>数字的细节如下：r记为4，w记为2，x记为1，可以有：<br>•0：无任何权限，即—-<br>•1：仅有x权限，即—x<br>•2：仅有w权限即-w-<br>•3：有w和x权限即-wx<br>•4：仅有r权限即r—<br>•5：有r和x权限即r-x<br>•6：有r和w权限即rw-<br>•7：有全部权限即rwx<br>所以751表示：rwx(7) r-x(5) —x(1)</p><p>•将hello.txt的权限修改为：r-x—xr-x，数字序号为：<br>chmod 515 hello.txt<br>•将hello.txt的权限修改为：-wx-w-rw-，数字序号为：<br>chmod 326 hello.txt<br>•序号123代表的权限是：<br>—x-w—wx</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>相对路径，绝对路径和特殊路径</title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/4.%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E3%80%81%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%89%B9%E6%AE%8A%E8%B7%AF%E5%BE%84%E7%AC%A6/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/4.%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E3%80%81%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%89%B9%E6%AE%8A%E8%B7%AF%E5%BE%84%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/38.png" alt="38"><br>我们当前在home目录,我们相当工作目录切换到home目录下的模板文件夹该如何操作？</p><ul><li>绝对路径:<br><img src="/img/39.png" alt="39"></li><li>相对路径<br><img src="/img/40.png" alt="40"><br>绝对路径：==以根目录为起点==，描述路径的一种写法，路径描述以/开头<br>相对路径：==以当前目录为起点==，描述路径的一种写法，路径描述无需以/开头</li></ul><p>特殊路径符：<br>.    表示当前目录，比如 cd ./Desktop 表示切换到当前目录下的Desktop目录内，和cd Desktop效果一致<br>..    表示上一级目录，比如：cd ..   即可切换到上一级目录，cd ../..  切换到上二级的目录<br>~    表示HOME目录，比如：cd ~    即可切换到HOME目录或cd ~/Desktop，切换到HOME内的Desktop目录</p><p><img src="/img/41.png" alt="41"></p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux目录结构</title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/1.Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/1.Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>Linux的目录结构是一个树型结构。<br>Windows 系统可以拥有多个盘符, 如 C盘、D盘、E盘。<br>Linux没有盘符这个概念, 只有一个根目录 /, 所有文件都在它下面。<br><img src="/img/24.png" alt="24"><br><img src="/img/25.png" alt="25"></p><h2 id="路径描述"><a href="#路径描述" class="headerlink" title="路径描述"></a>路径描述</h2><p>在Linux系统中，路径之间的层级关系，使用：/ 来表示<br>在Windows系统中，路径之间的层级关系，使用： \ 来表示<br><img src="/img/26.png" alt="26"><br>D:\data\work\hello.txt</p><p><img src="/img/27.png" alt="27"><br>/usr/local/hello.txt</p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础命令</title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/0.Linux%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/0.Linux%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="命令和命令行"><a href="#命令和命令行" class="headerlink" title="命令和命令行"></a>命令和命令行</h2><ul><li>命令:Linux系统操作指令,可以以字符化的形式去使用,一个命令其实就对应一个程序</li><li>命令行:Linux终端,可以提供字符化的操作页面供命令执行</li></ul><h2 id="命令的通用格式"><a href="#命令的通用格式" class="headerlink" title="命令的通用格式"></a>命令的通用格式</h2><p>无论是什么命令，用于什么用途，在Linux中，命令有其通用的格式：<br><img src="/img/28.png" alt="28"><br>command： 命令本身<br>-options：[可选，非必填]命令的一些选项，可以通过选项控制命令的行为细节<br>parameter：[可选，非必填]命令的参数，多数用于命令的指向目标等<br>语法中的[]，表示可选的意思</p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/%E5%88%9D%E8%AF%86Linux/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/%E5%88%9D%E8%AF%86Linux/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<ul><li>计算机由硬件和软件所组成。</li><li>操作系统是软件的一类,协助用户调度硬件工作,充当用户和计算机之间的桥梁。</li><li>当计算机拥有了操作系统，就相当于拥有了灵魂，操作系统可以：<br>1.调度CPU进行工作<br>2.调度内存进行工作<br>3.调度硬盘进行数据存储<br>4.调度网卡进行网络通讯<br>5.调度音响发出声音<br>6.调度打印机打印内容<br><img src="/img/22.png" alt="22"></li><li>常见的操作系统有：PC端：Windows、Linux、MacOS;<br>移动端：Android、IOS、鸿蒙系统。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> 初识Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux初识</title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/%E5%88%9D%E8%AF%86Linux/2.Linux%E5%88%9D%E8%AF%86/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/%E5%88%9D%E8%AF%86Linux/2.Linux%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux系统的组成"><a href="#Linux系统的组成" class="headerlink" title="Linux系统的组成"></a>Linux系统的组成</h2><ul><li>Linux系统内核</li><li>系统级应用程序<br>其中我们的内核提供最核心的功能,比如调度CPU,调度内存等。<br>而系统级应用程序可以理解为出场自带程序,它们可以去调用系统内核实现相关功能。<br><img src="/img/23.png" alt="23"><br><a href="https://www.kernel.org">https://www.kernel.org</a> 可以看到内核的源码。<h2 id="Linux发行版"><a href="#Linux发行版" class="headerlink" title="Linux发行版"></a>Linux发行版</h2>内核是免费、开源的，这也就代表了：<br>•任何人都可以获得并修改内核，并且自行集成系统级程序<br>•提供了内核+系统级程序的完整封装，称之为Linux发行版<br>每个人都可以有自己的Linux发行版,目前主流的有:Centos,Ubuntu等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> 初识Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机</title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/%E5%88%9D%E8%AF%86Linux/3.%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/%E5%88%9D%E8%AF%86Linux/3.%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<ul><li>虚拟机是借助虚拟化技术，我们可以在系统中，通过软件：模拟计算机硬件，并给虚拟硬件安装真实的操作系统。这样，就可以在电脑中，虚拟出一个完整的电脑。</li><li>通过虚拟机的形式，得到可以用的Linux系统环境。</li></ul><p>我们知道了可以通过虚拟化技术得到虚拟化的硬件,如何实现?<br>可以通过虚拟化的软件去获得虚拟机。<br>虚拟化的软件包括很多,这里推荐VMware。我们有了虚拟化的硬件,还需要一个操作系统,需要下载Centos,Ubuntu等。<br>下载教程可以看CSDN里面的博客:<br>VMware下载教程:<a href="https://blog.csdn.net/2301_76831056/article/details/142767172?ops_request_misc=elastic_search_misc&amp;request_id=7269cc644701a300f8719f9ae60cb5dc&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-142767172-null-null.142^v102^pc_search_result_base2&amp;utm_term=VMware%E4%B8%8B%E8%BD%BD&amp;spm=1018.2226.3001.4187">VMware虚拟机17.6版本下载与安装(宝宝级攻略)_vmware17.6-CSDN博客</a></p><p>Centos操作系统下载教程:<a href="https://blog.csdn.net/m0_62854966/article/details/147264214">Linux：安装 CentOS 7（完整教程）_centos7-CSDN博客</a></p><p>Ubuntu操作系统下载教程:<a href="https://blog.csdn.net/weixin_52799373/article/details/139055794?ops_request_misc=elastic_search_misc&amp;request_id=5c1acf8973de63587aa32cca54e9a7ab&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-139055794-null-null.142^v102^pc_search_result_base2&amp;utm_term=Ubuntu&amp;spm=1018.2226.3001.4187">VMware虚拟机安装Ubuntu教程(超详细)_vmware安装ubuntu-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> 初识Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程连接Linux系统</title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/%E5%88%9D%E8%AF%86Linux/4.%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Linux%E7%B3%BB%E7%BB%9F/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/%E5%88%9D%E8%AF%86Linux/4.%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Linux%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>对于操作系统的使用，有2种使用形式：<br>•图形化页面使用操作系统<br>•以命令的形式使用操作系统<br>不论是Windows还是Linux亦或是MacOS系统，都是支持这两种使用形式。<br>•图形化：使用操作系统提供的图形化页面，以获得图形化反馈的形式去使用操作系统。<br>•命令行：使用操作系统提供的各类命令，以获得字符反馈的形式去使用操作系统。</p><p>对于Linux系统我们更多的是去使用命令的形式去使用。</p><p>既然决定使用命令行去学习Linux操作系统，那么就必须丰富一下工具的使用。<br>我们使用VMware可以得到Linux虚拟机，但是在VMware中操作Linux的命令行页面不太方便，主要是：<br>•内容的复制、粘贴跨越VMware不方便<br>•文件的上传、下载跨越VMware不方便<br>•也就是和Linux系统的各类交互，跨越VMware不方便<br>我们可以通过第三方软件，FinalShell，远程连接到Linux操作系统之上。并通过FinalShell去操作Linux系统。这样各类操作都会十分的方便。</p><p>FinalShell下载教程:<a href="https://blog.csdn.net/2503_91826368/article/details/147596825?ops_request_misc=elastic_search_misc&amp;request_id=8e0f252917027f3e957ec06c76115758&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-147596825-null-null.142^v102^pc_search_result_base2&amp;utm_term=finalshell%E4%B8%8B%E8%BD%BD&amp;spm=1018.2226.3001.4187">超级详细的 FinalShell下载安装 及使用教程（附安装包）-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> 初识Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机快照</title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/%E5%88%9D%E8%AF%86Linux/6.%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BF%AB%E7%85%A7/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/%E5%88%9D%E8%AF%86Linux/6.%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BF%AB%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<p>VMware虚拟机（Workstation和Funsion）支持为虚拟机制作快照。<br>通过快照将当前虚拟机的状态保存下来，在以后可以通过快照恢复虚拟机到保存的状态。</p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> 初识Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL2</title>
      <link href="/2026/02/09/Linux%E5%9F%BA%E7%A1%80/%E5%88%9D%E8%AF%86Linux/5.WSL2/"/>
      <url>/2026/02/09/Linux%E5%9F%BA%E7%A1%80/%E5%88%9D%E8%AF%86Linux/5.WSL2/</url>
      
        <content type="html"><![CDATA[<p>WSL：Windows Subsystem for Linux，是用于Windows系统之上的Linux子系统。<br>作用很简单，可以在Windows系统中获得Linux系统环境，并完全直连计算机硬件，无需通过虚拟机虚拟硬件。</p><p>下载使用教程:<a href="https://blog.csdn.net/l827893628/article/details/148927724?ops_request_misc=elastic_search_misc&amp;request_id=15e86d427fa90565cf00a804cfc1115f&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-148927724-null-null.142^v102^pc_search_result_base2&amp;utm_term=WSL&amp;spm=1018.2226.3001.4187">2025最新 WSL（Windows Subsystem for Linux）安装教程 （保姆级，图文讲解，带安装包）_wsl安装-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> 初识Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>油漆</title>
      <link href="/2026/02/08/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/20.%E6%B2%B9%E6%BC%86/"/>
      <url>/2026/02/08/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/20.%E6%B2%B9%E6%BC%86/</url>
      
        <content type="html"><![CDATA[<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h3><p>第一行两个整数 $n, m$，分别表示油漆的罐数和专家进行的操作数。<br>接下来 $m$ 行，每行三个整数 $l_i, r_i, k_i$，表示在第 $i$ 次操作中向编号在 $l_i$ 到 $r_i$ 之间（包括两端）的罐子中加入颜料。加入的颜料是黄色（$k_i=1$），蓝色（$k_i=2$）或红色（$k_i=3$）中的一种。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h3><p>输出一行一个整数，表示在所有操作之后绿色油漆的罐数。</p><h3 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a><strong>说明/提示</strong></h3><p>判断一罐油漆最后是不是<strong>绿色</strong>，必须<strong>同时满足</strong>以下三个条件：</p><ol><li><strong>必有黄色</strong> ($Yellow &gt; 0$)</li><li><strong>必须有蓝色</strong> ($Blue &gt; 0$)</li><li><strong>绝对不能有红色</strong> ($Red == 0$)</li></ol><p>开辟三个数组统计每个位置上各种颜色颜料的数量<br>通过差分数组来模拟在区间上加入颜料的操作<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n,cnt=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">yellow</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">blue</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">red</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,k;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">        yellow[l<span class="number">-1</span>]+=<span class="number">1</span>,yellow[r]-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">2</span>)</span><br><span class="line">        blue[l<span class="number">-1</span>]+=<span class="number">1</span>,blue[r]-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">3</span>)</span><br><span class="line">        red[l<span class="number">-1</span>]+=<span class="number">1</span>,red[r]-=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    yellow[i]+=yellow[i<span class="number">-1</span>],blue[i]+=blue[i<span class="number">-1</span>],red[i]+=red[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="keyword">if</span>(yellow[i]&gt;<span class="number">0</span>&amp;&amp;blue[i]&gt;<span class="number">0</span>&amp;&amp;red[i]==<span class="number">0</span>)</span><br><span class="line">    cnt++;</span><br><span class="line">    cout&lt;&lt;cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 差分题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>棋盘</title>
      <link href="/2026/02/08/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/21.%E6%A3%8B%E7%9B%98/"/>
      <url>/2026/02/08/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/21.%E6%A3%8B%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h3><p>小蓝拥有 $n \times n$ 大小的棋盘，一开始棋盘上全都是白子。小蓝进行了 $m$ 次操作，每次操作会将棋盘上某个范围内的所有棋子的颜色取反（也就是白色棋子变为黑色，黑色棋子变为白色）。请输出所有操作做完后棋盘上每个棋子的颜色。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h3><p>输入的第一行包含两个整数 $n, m$，用一个空格分隔，表示棋盘大小与操作数。<br>接下来 $m$ 行每行包含四个整数 $x_1, y_1, x_2, y_2$，相邻整数之间使用一个空格分隔，表示将在 $x_1$ 至 $x_2$ 行和 $y_1$ 至 $y_2$ 列中的棋子颜色取反。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h3><p>输出 $n$ 行，每行 $n$ 个 0 或 1 表示该位置棋子的颜色。如果是白色则输出 0，否则输出 1。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a><strong>样例输入</strong></h3><p>Plaintext<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 1 2 2</span><br><span class="line">2 2 3 3</span><br><span class="line">1 1 3 3</span><br></pre></td></tr></table></figure></p><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a><strong>样例输出</strong></h3><p>Plaintext<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">001</span><br><span class="line">010</span><br><span class="line">100</span><br></pre></td></tr></table></figure></p><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a><strong>评测用例规模与约定</strong></h3><p>对于 30% 的评测用例， $n, m \le 500$；<br>对于所有评测用例， $1 \le n, m \le 2000$，$1 \le x_1 \le x_2 \le n$，$1 \le y_1 \le y_2 \le m$。</p><p>二维异或差分,每次取反就相当于异或1<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">arr</span>(n<span class="number">+2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+2</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        arr[x1][y1]^=<span class="number">1</span>,arr[x1][y2<span class="number">+1</span>]^=<span class="number">1</span>;</span><br><span class="line">        arr[x2<span class="number">+1</span>][y1]^=<span class="number">1</span>,arr[x2<span class="number">+1</span>][y2<span class="number">+1</span>]^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)</span><br><span class="line">        arr[i][j]^=arr[i][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)</span><br><span class="line">        arr[j][i]^=arr[j<span class="number">-1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        cout&lt;&lt;arr[i][j];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 差分题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新排序</title>
      <link href="/2026/02/08/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/22.%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/2026/02/08/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/22.%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：重新排序"><a href="#题目：重新排序" class="headerlink" title="题目：重新排序"></a>题目：重新排序</h3><p><strong>【问题描述】</strong><br>给定一个数组 $A$ 和一些查询 $L_i, R_i$，求数组中第 $L_i$ 至第 $R_i$ 个元素之和。<br>小蓝觉得这个问题很无聊，于是他想重新排列一下数组，使得最终每个查询结果的和尽可能地大。小蓝想知道相比原数组，所有查询结果的总和最多可以增加多少？<br><strong>【输入格式】</strong><br>输入第一行包含一个整数 $n$。<br>第二行包含 $n$ 个整数 $A_1, A_2, \cdots, A_n$。相邻两个整数之间用一个空格分隔。<br>第三行包含一个整数 $m$ 表示查询的数目。<br>接下来 $m$ 行，每行包含两个整数 $L_i, R_i$。相邻两个整数之间用一个空格分隔。<br><strong>【输出格式】</strong><br>输出一行包含一个整数表示答案。<br><strong>【样例输入】</strong><br>Plaintext<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">2</span><br><span class="line">1 3</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure><br><strong>【样例输出】</strong><br>Plaintext<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><br><strong>【样例说明】</strong><br>原来的和为 $6 + 14 = 20$，重新排列为 $(1, 4, 5, 2, 3)$ 后和为 $10 + 14 = 24$，增加了 4。<br><strong>【评测用例规模与约定】</strong><br>对于所有评测用例，$1 \le n, m \le 10^5, 1 \le A_i \le 10^6, 1 \le L_i \le R_i \le 10^6$。</p><p>想要查询的部分和最大,我们可以统计每个位置被统计的次数然后被查询次数越多的位置放的数越大,这样就可以使查询部分和最大。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,total=<span class="number">0</span>,atotal=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">arr</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">sum</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">        sum[i]=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">num</span>(n<span class="number">+2</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        num[l]+=<span class="number">1</span>;</span><br><span class="line">        num[r<span class="number">+1</span>]-=<span class="number">1</span>;</span><br><span class="line">        total+=sum[r]-sum[l<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    num[i]+=num[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">sort</span>(num.<span class="built_in">begin</span>()<span class="number">+1</span>,num.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>()<span class="number">+1</span>,arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    atotal+=num[i]*arr[i];</span><br><span class="line">    cout&lt;&lt;atotal-total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 差分题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分</title>
      <link href="/2026/02/07/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/19.%E5%B7%AE%E5%88%86/"/>
      <url>/2026/02/07/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/19.%E5%B7%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="快速处理区间加减-前缀和的逆运算"><a href="#快速处理区间加减-前缀和的逆运算" class="headerlink" title="快速处理区间加减(前缀和的逆运算)"></a>快速处理区间加减(前缀和的逆运算)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line"> d[i]=a[i];</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> d[i]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 1 1 1                                      1 1 1 1<br>前缀和得到                               差分得到<br>1 2 3 4                                      1 0 0 0<br>差分得到                                   前缀和得到<br>1 1 1 1 恢复为原数组                 1  1 1 1  恢复为原数组</p><h2 id="和前缀和互为逆运算："><a href="#和前缀和互为逆运算：" class="headerlink" title="和前缀和互为逆运算："></a>和前缀和互为逆运算：</h2><p>前缀和数组做差分:</p><ul><li><script type="math/tex; mode=display">s_i = a_0 + a_1 + \dots + a_{i-1} + a_i</script></li><li>($i$ 位置的前缀和是 $0$ 到 $i$ 的总和)</li><li><script type="math/tex; mode=display">s_{i-1} = a_0 + a_1 + \dots + a_{i-1}</script></li><li>($i-1$ 位置的前缀和是 $0$ 到 $i-1$ 的总和)</li><li><strong>相减得出</strong>：<script type="math/tex; mode=display">s_i - s_{i-1} = a_i</script></li><li>这意味着：前缀和数组的<strong>差分</strong>（相邻项相减）就是原数组的元素。</li></ul><p>差分数组计算前缀和:</p><ul><li><script type="math/tex; mode=display">d_i = a_i - a_{i-1}</script></li><li><script type="math/tex; mode=display">d_{i-1} = a_{i-1} - a_{i-2}</script></li><li>… （中间省略）</li><li><script type="math/tex; mode=display">d_1 = a_1 - a_0</script></li><li><script type="math/tex; mode=display">d_0 = a_0</script></li><li><strong>左边相加</strong>：<br><script type="math/tex">d_0 + d_1 + \dots + d_i</script>这实际上就是在对差分数组 $d$ 求前缀和。</li></ul><h2 id="a-l-r-k-Longleftrightarrow-d-l-k-quad-d-r-1-k"><a href="#a-l-r-k-Longleftrightarrow-d-l-k-quad-d-r-1-k" class="headerlink" title="$a[l, r] + k \Longleftrightarrow d[l] + k, \quad d[r+1] - k$"></a>$a[l, r] + k \Longleftrightarrow d[l] + k, \quad d[r+1] - k$</h2><p>如果你想给原数组 $a$ 的区间 $[l, r]$ 内的所有数字都加上 $k$，你只需要在差分数组 $d$ 的左边界 $l$ 处加上 $k$，并在右边界的下一个位置 $r+1$ 处减去 $k$。<br><img src="/img/1.png" alt="1"><br><img src="/img/2.png" alt="2"></p><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><p>先对每一列差分,再对每一行差分<br><img src="/img/3.png" alt="3"></p><h2 id="异或差分"><a href="#异或差分" class="headerlink" title="异或差分"></a>异或差分</h2><p><img src="/img/4.png" alt="4"></p><h3 id="第一步：构造异或差分数组"><a href="#第一步：构造异或差分数组" class="headerlink" title="第一步：构造异或差分数组"></a>第一步：构造异或差分数组</h3><p>将原数组转化为一个“异或差分”序列。</p><ul><li><strong>计算规则：</strong> 差分数组 $d[i] = a[i] \oplus a[i-1]$（规定 $a[0] = 0$）。</li><li><strong>图片示例：</strong> 原数组 <code>[1, 2, 3, 4, 5, 6]</code> 经过“差分”后变为 <code>[1, 3, 1, 7, 1, 3]</code>。<ul><li>$1 \oplus 0 = 1$</li><li>$2 \oplus 1 = 3$</li><li>$3 \oplus 2 = 1$</li><li>以此类推。<h3 id="第二步：执行区间异或操作"><a href="#第二步：执行区间异或操作" class="headerlink" title="第二步：执行区间异或操作"></a>第二步：执行区间异或操作</h3>假设要在区间 $[l, r]$ 上统一异或一个值 $k$。在差分数组上，这只需要修改两个点。</li></ul></li><li><strong>操作公式：</strong><ol><li>$d[l] = d[l] \oplus k$</li><li>$d[r+1] = d[r+1] \oplus k$</li></ol></li><li><strong>图片示例：</strong> 对区间 $[2, 5]$ 执行 <code>^ 2</code>（异或 2）。<ul><li>修改左端点（索引 2）：原来的 $3 \oplus 2 = 1$。</li><li>修改右端点外侧（索引 6）：原来的 $3 \oplus 2 = 1$。</li><li>修改后的差分数组变为：<code>[1, 1, 1, 7, 1, 1]</code>。<h3 id="第三步：还原结果（前缀异或和）"><a href="#第三步：还原结果（前缀异或和）" class="headerlink" title="第三步：还原结果（前缀异或和）"></a>第三步：还原结果（前缀异或和）</h3>通过对修改后的差分数组求<strong>前缀异或和</strong>，得到最终的修改结果。</li></ul></li><li><strong>计算公式：</strong> $a’[i] = d[1] \oplus d[2] \oplus \dots \oplus d[i]$。</li><li><strong>图片示例：</strong> 对 <code>[1, 1, 1, 7, 1, 1]</code> 求前缀异或和。<ol><li>第 1 位：$1$</li><li>第 2 位：$1 \oplus 1 = 0$</li><li>第 3 位：$0 \oplus 1 = 1$</li><li>第 4 位：$1 \oplus 7 = 6$</li><li>第 5 位：$6 \oplus 1 = 7$</li><li>第 6 位：$7 \oplus 1 = 6$</li></ol></li><li><strong>最终数组：</strong> <code>[1, 0, 1, 6, 7, 6]</code>。<br>对于区间 $[l, r]$ 进行异或 $k$ 的操作，其差分逻辑为：</li></ul><script type="math/tex; mode=display">d[l] = d[l] \oplus k</script><script type="math/tex; mode=display">d[r+1] = d[r+1] \oplus k</script><h2 id="利用多重差分来解决多项式形式的区间修改"><a href="#利用多重差分来解决多项式形式的区间修改" class="headerlink" title="利用多重差分来解决多项式形式的区间修改"></a>利用<strong>多重差分</strong>来解决<strong>多项式形式的区间修改</strong></h2><p><img src="/img/5.png" alt="5"></p><h3 id="1-核心概念：差分与导数的关系"><a href="#1-核心概念：差分与导数的关系" class="headerlink" title="1. 核心概念：差分与导数的关系"></a>1. 核心概念：差分与导数的关系</h3><p>在离散数学中，<strong>差分（Difference）</strong>之于数列，就相当于<strong>导数（Derivative）</strong>之于连续函数。</p><ul><li>常数的导数是 0。</li><li>$x$（一次函数）的导数是常数。</li><li>$x^2$（二次函数）的导数是一次函数。<br><strong>差分也是同理：</strong><br>每一次差分操作，都会把多项式的最高次幂降低 1 次。<h3 id="2-图片公式逐行详解"><a href="#2-图片公式逐行详解" class="headerlink" title="2. 图片公式逐行详解"></a>2. 图片公式逐行详解</h3>图片中列举了不同复杂度的修改（$add_x$），以及它们对应的处理方式。<h4 id="第一行：-add-x-a-（常数修改）"><a href="#第一行：-add-x-a-（常数修改）" class="headerlink" title="第一行：$add_x = a$ （常数修改）"></a><strong>第一行：$add_x = a$ （常数修改）</strong></h4></li><li><strong>含义</strong>：这是最基础的区间修改。比如“给区间 $[L, R]$ 的每个数都加上常数 $a$”。</li><li><strong>多项式次数</strong>：$0$ 次（因为 $a = a \cdot x^0$）。</li><li><strong>所需差分阶数</strong>：<strong>一阶差分</strong>。</li><li><strong>原理</strong>：<br>  常数序列（如 $3, 3, 3, 3$）做一次差分后，中间全是 $0$（除了边界）。<ul><li>原数：$0, 0, 3, 3, 3, 3, 0$</li><li>一阶差分：$0, 0, 3, 0, 0, 0, -3$</li><li><strong>结论</strong>：只需要修改两个点（$L$ 和 $R+1$），就能代表整个区间的修改。<h4 id="第二行：-add-x-a-bx-（线性-等差数列修改）"><a href="#第二行：-add-x-a-bx-（线性-等差数列修改）" class="headerlink" title="第二行：$add_x = a + bx$ （线性/等差数列修改）"></a><strong>第二行：$add_x = a + bx$ （线性/等差数列修改）</strong></h4></li></ul></li><li><strong>含义</strong>：给区间加上一个等差数列。比如“给第 $x$ 个数加上 $2x+1$”。</li><li><strong>多项式次数</strong>：$1$ 次。</li><li><strong>所需差分阶数</strong>：<strong>二阶差分</strong>。</li><li><strong>原理</strong>：<ul><li>原增量序列（线性）：$1, 3, 5, 7, 9$ （这是一个一次函数）</li><li>一阶差分：$1, 2, 2, 2, 2$ （变成了常数序列，除了开头）</li><li>二阶差分：$1, 1, 0, 0, 0$ （中间变成了 0）</li><li><strong>结论</strong>：对一个线性增长的区间修改，维护二阶差分数组，只需要在边界处进行 $O(1)$ 的修改。<h4 id="第三行：-add-x-a-bx-cx-2-（二次函数修改）"><a href="#第三行：-add-x-a-bx-cx-2-（二次函数修改）" class="headerlink" title="第三行：$add_x = a + bx + cx^2$ （二次函数修改）"></a><strong>第三行：$add_x = a + bx + cx^2$ （二次函数修改）</strong></h4></li></ul></li><li><strong>含义</strong>：给区间加上一个平方级别的增长量。比如“物理中的匀加速运动位移”。</li><li><strong>多项式次数</strong>：$2$ 次。</li><li><strong>所需差分阶数</strong>：<strong>三阶差分</strong>。</li><li><p><strong>原理</strong>：</p><ul><li>$x^2$ 做差分变成 $(x+1)^2 - x^2 = 2x+1$（降级为一次函数）。</li><li>再做差分变成常数。</li><li>再做差分变成 0。</li><li><strong>结论</strong>：只要是 $n$ 次多项式，做 $n+1$ 次差分后，区间内部的值就会变成 0，只剩下边界有值。<h3 id="3-为什么是“多项式累加-Longrightarrow-多重差分”？"><a href="#3-为什么是“多项式累加-Longrightarrow-多重差分”？" class="headerlink" title="3. 为什么是“多项式累加 $\Longrightarrow$ 多重差分”？"></a>3. 为什么是“多项式累加 $\Longrightarrow$ 多重差分”？</h3>这张图推导出的通用法则是：</li></ul></li></ul><ol><li><strong>降维打击</strong>：利用差分性质，把复杂的曲线（高次多项式）通过多次差分“打平”成 0。</li><li><strong>操作</strong>：<ul><li>如果你要加一个 <strong>$k$ 次多项式</strong>。</li><li>你就建立一个 <strong>$k+1$ 阶差分数组</strong>。</li><li>你只需要在这个高阶差分数组的 <strong>$L$（起点）</strong> 和 <strong>$R$（终点）</strong> 附近修改少数几个值。</li></ul></li><li><strong>还原</strong>：<ul><li>当询问最终结果时，对这个 $k+1$ 阶差分数组做 <strong>$k+1$ 次前缀和（Prefix Sum）</strong>，就能还原出原始数组的增量。</li></ul></li></ol><h2 id="差分的正负性反应了原数组的增减性"><a href="#差分的正负性反应了原数组的增减性" class="headerlink" title="差分的正负性反应了原数组的增减性"></a>差分的正负性反应了原数组的增减性</h2><p><img src="/img/6.png" alt="6"></p><h3 id="1-核心逻辑：从“面”到“点”的降维"><a href="#1-核心逻辑：从“面”到“点”的降维" class="headerlink" title="1. 核心逻辑：从“面”到“点”的降维"></a>1. 核心逻辑：从“面”到“点”的降维</h3><ul><li><strong>左边（原数组视角）</strong>：<ul><li><strong>操作</strong>：<code>任选 [L, R]</code>，让区间内所有元素加 1 或减 1。</li><li><strong>难点</strong>：每次操作涉及很多个数，状态难以穷举。</li><li><strong>目标</strong>：想让原数组变成<strong>递增</strong>、<strong>递减</strong>或者<strong>所有数相等</strong>。</li></ul></li><li><strong>右边（差分数组视角）</strong>：<ul><li><strong>操作</strong>：由于差分的性质（$D[L]+v, D[R+1]-v$），原数组的一次区间修改，等价于在差分数组中<strong>任选两个位置</strong>，一个加 1，一个减 1。<ul><li>_特殊情况_：如果只选一个位置修改（比如只改 $L$ 处），其实是因为另一个位置选在了 $N+1$（越界无效位置），图中的 <code>X | 1 2 3 4 | X</code> 就在暗示这种边界处理。</li></ul></li><li><strong>优势</strong>：操作从“修改一排数”变成了“修改两个数”，复杂度大大降低。</li><li><strong>目标</strong>：<ul><li>原数组<strong>递增</strong> $\Longleftrightarrow$ 差分数组每一项（除第一项外）都 $\ge 0$。</li><li>原数组<strong>递减</strong> $\Longleftrightarrow$ 差分数组每一项（除第一项外）都 $\le 0$。</li><li>原数组<strong>相等</strong> $\Longleftrightarrow$ 差分数组每一项（除第一项外）都 $= 0$。<h3 id="2-经典案例解析：IncDec-Sequence"><a href="#2-经典案例解析：IncDec-Sequence" class="headerlink" title="2. 经典案例解析：IncDec Sequence"></a>2. 经典案例解析：IncDec Sequence</h3>这张图其实对应了一道非常经典的算法题（NOIp 2011 提高组《IncDec Sequence》）。<br><strong>问题描述</strong><br>给定一个数组，每次可以选择一个区间 $[L, R]$ 进行 $+1$ 或 $-1$ 操作。问最少操作多少次，能让数组中<strong>所有元素都相等</strong>？<br><strong>结合这张图的解法</strong>：</li></ul></li></ul></li></ul><ol><li><strong>转化目标</strong>：<br> 让“原数组所有元素相等”，等价于让“差分数组 $D[2], D[3] \dots D[n]$ 全部变为 0”。（注意 $D[1]$ 不需要为 0，因为 $D[1]$ 决定了最终相等的那个数值是多少）。</li><li><strong>分析现状</strong>：<br> 计算出初始的差分数组后，你会发现 $D[2 \dots n]$ 中有一些<strong>正数</strong>（需要减），有一些<strong>负数</strong>（需要加）。</li><li><strong>匹配操作（图中的“任选两个位置”）</strong>：<ul><li><strong>贪心策略 1</strong>：优先在 $D[2 \dots n]$ 内部找一正一负进行配对。比如 $D[i] &gt; 0, D[j] &lt; 0$，我们就对区间 $[i, j-1]$ 操作。这样能一次性解决两个数的偏差（“一个加，一个减”），效率最高。</li><li><strong>贪心策略 2</strong>：如果正负无法配对（比如只剩下正数了），那就只能和边界（$D[1]$ 或 $D[n+1]$）配对。这对应图中“任选一个位置，增加/减少”。</li></ul></li><li><strong>结论</strong>：<br> 通过把复杂的区间问题转化为差分数组上的<strong>正负数抵消</strong>游戏，我们可以瞬间得出最少操作次数公式：$\max(\text{正数和}, |\text{负数和}|)$。<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3>这张图想表达的是差分技术的<strong>最高境界</strong>：<br>不仅仅是用它来快速修改数据（如前两张图所述），而是用它来<strong>重构问题的定义</strong>。</li></ol><ul><li><strong>看到“区间加减”</strong> $\rightarrow$ 转化为 <strong>“差分数组的两点修改”</strong>。</li><li><strong>看到“单调性/相等”目标</strong> $\rightarrow$ 转化为 <strong>“差分数组的正负/零”目标</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 差分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL库</title>
      <link href="/2026/02/07/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/C++STL%E5%BA%93/"/>
      <url>/2026/02/07/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/C++STL%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="向量-vector"><a href="#向量-vector" class="headerlink" title="向量 vector"></a>向量 <a href="https://zh.cppreference.com/w/cpp/container/vector">vector</a></h2><p><strong><code>#include &lt;vector&gt;</code></strong><br>连续的顺序的储存结构（和数组一样的类别），但是有长度可变的特性。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p><strong><code>vector&lt;类型&gt; arr(长度, [初值])</code></strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>,<span class="number">0</span>)</span></span>; <span class="comment">//构造初始长为100的int一维数组,初始值全为0</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">arr</span>(<span class="number">100</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//构造行数为100,列数不定的二维数组</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">arr</span>(<span class="number">100</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">666</span>,<span class="number">-1</span>)); <span class="comment">//构造行数为100,列数为666的二维数组,初始值为-1</span></span><br></pre></td></tr></table></figure></p><h4 id="尾接-amp-尾删"><a href="#尾接-amp-尾删" class="headerlink" title="尾接 &amp; 尾删"></a>尾接 &amp; 尾删</h4><ul><li><strong><code>.push_back(元素)</code></strong>：在 vector 尾接一个元素</li><li><strong><code>.pop_back()</code></strong>：删除 vector 尾部的一个元素<h4 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h4><strong><code>.size()</code></strong><br>获取当前 vector 的长度<h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><strong><code>.clear()</code></strong><br>清空 vector<h4 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h4><strong><code>.empty()</code></strong><br>如果是空返回 <code>true</code> 反之返回 <code>false</code>.<h4 id="改变长度"><a href="#改变长度" class="headerlink" title="改变长度"></a>改变长度</h4><strong><code>.resize(新长度, [默认值])</code></strong><br>修改 vector 的长度</li><li>如果是缩短，则删除多余的值</li><li>如果是扩大，且指定了默认值，则新元素均为默认值（旧元素不变）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">arr</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:arr)</span><br><span class="line">    cout&lt;&lt;x;  <span class="comment">//111</span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    arr.<span class="built_in">resize</span>(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:arr)</span><br><span class="line">    cout&lt;&lt;x; <span class="comment">//1110</span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    arr.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:arr)</span><br><span class="line">    cout&lt;&lt;x; <span class="comment">//11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 <a href="https://zh.cppreference.com/w/cpp/container/stack">stack</a></h2><p>通过二次封装双端队列 (deque) 容器，实现先进后出的栈数据结构。</p><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>构造</td><td><code>stack&lt;类型&gt; stk</code></td><td><code>stack&lt;int&gt; stk;</code></td></tr><tr><td>进栈</td><td><code>.push(元素)</code></td><td><code>stk.push(1);</code></td></tr><tr><td>出栈</td><td><code>.pop()</code></td><td><code>stk.pop();</code></td></tr><tr><td>取栈顶</td><td><code>.top()</code></td><td><code>int a = stk.top();</code></td></tr><tr><td>查看大小 / 清空 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><h2 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列 queue"></a>队列 <a href="https://zh.cppreference.com/w/cpp/container/queue">queue</a></h2><p><strong><code>#include &lt;queue&gt;</code></strong><br>通过二次封装双端队列 (deque) 容器，实现先进先出的队列数据结构。</p><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>构造</td><td><code>queue&lt;类型&gt; que</code></td><td><code>queue&lt;int&gt; que;</code></td></tr><tr><td>进队</td><td><code>.push(元素)</code></td><td><code>que.push(1);</code></td></tr><tr><td>出队</td><td><code>.pop()</code></td><td><code>que.pop();</code></td></tr><tr><td>取队首</td><td><code>.front()</code></td><td><code>int a = que.front();</code></td></tr><tr><td>取队尾</td><td><code>.back()</code></td><td><code>int a = que.back();</code></td></tr><tr><td>查看大小 / 清空 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><h2 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列 priority_queue"></a>优先队列 <a href="https://zh.cppreference.com/w/cpp/container/priority_queue">priority_queue</a></h2><p><strong><code>#include &lt;queue&gt;</code></strong><br>提供常数时间的最大元素查找，对数时间的插入与提取，底层原理是二叉堆。</p><h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h4><p><strong><code>priority_queue&lt;类型, 容器, 比较器&gt; pque</code></strong></p><ul><li>类型：要储存的数据类型</li><li>容器：储存数据的底层容器，默认为 <code>vector&lt;类型&gt;</code>，竞赛中保持默认即可</li><li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pque1;                            <span class="comment">// 储存int的大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pque2; <span class="comment">// 储存int的小顶堆</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>进堆</td><td><code>.push(元素)</code></td><td><code>que.push(1);</code></td></tr><tr><td>出堆</td><td><code>.pop()</code></td><td><code>que.pop();</code></td></tr><tr><td>取堆顶</td><td><code>.top()</code></td><td><code>int a = que.top();</code></td></tr><tr><td>查看大小 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt;pque;</span><br><span class="line"> pque.<span class="built_in">push</span>(<span class="number">6</span>);</span><br><span class="line"> pque.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line"> pque.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"> cout&lt;&lt;pque.<span class="built_in">top</span>()&lt;&lt;endl; <span class="comment">//6</span></span><br><span class="line"> pque.<span class="built_in">pop</span>();</span><br><span class="line"> cout&lt;&lt;pque.<span class="built_in">top</span>();  <span class="comment">//5</span></span><br></pre></td></tr></table></figure><h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 <a href="https://zh.cppreference.com/w/cpp/container/set">set</a></h2><p><strong><code>#include &lt;set&gt;</code></strong><br>提供对数时间的插入、删除、查找的集合数据结构。底层原理是红黑树。</p><div class="table-container"><table><thead><tr><th>集合三要素</th><th>解释</th><th>set</th><th>multiset</th><th>unordered_set</th></tr></thead><tbody><tr><td>确定性</td><td>一个元素要么在集合中，要么不在</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>互异性</td><td>一个元素仅可以在集合中出现一次</td><td>✔</td><td>❌（任意次）</td><td>✔</td></tr><tr><td>无序性</td><td>集合中的元素是没有顺序的</td><td>❌（从小到大）</td><td>❌（从小到大）</td><td>✔</td></tr></tbody></table></div><h3 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h4><p><strong><code>set&lt;类型, 比较器&gt; st</code></strong></p><ul><li>类型：要储存的数据类型</li><li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; st1;               <span class="comment">// 储存int的集合（从小到大）</span></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; st2; <span class="comment">// 储存int的集合（从大到小）</span></span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4>可使用迭代器进行遍历：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure>基于范围的循环（C++ 11）：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ele : st)</span><br><span class="line">    cout &lt;&lt; ele &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4></li></ul><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>插入元素</td><td><code>.insert(元素)</code></td><td><code>st.insert(1);</code></td></tr><tr><td>删除元素</td><td><code>.erase(元素)</code></td><td><code>st.erase(2);</code></td></tr><tr><td>查找元素</td><td><code>.find(元素)</code></td><td><code>auto it = st.find(1);</code></td></tr><tr><td>判断元素是否存在</td><td><code>.count(元素)</code></td><td><code>st.count(3);</code></td></tr><tr><td>查看大小 / 清空 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><p>对于查找元素的find</p><ul><li><strong>找到了</strong> → 返回指向该元素的 <strong>迭代器</strong></li><li><strong>没找到</strong> → 返回 <code>st.end()</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:s)</span><br><span class="line">cout&lt;&lt;x;</span><br><span class="line"><span class="keyword">auto</span> it=s.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">cout&lt;&lt;s.<span class="built_in">count</span>(<span class="number">4</span>)&lt;&lt;s.<span class="built_in">count</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>set 的迭代器不能像 vector 一样相减得到下标。<strong>下面是错误用法：</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = st.<span class="built_in">find</span>(<span class="number">2</span>);      <span class="comment">// 正确，返回2所在位置的迭代器。</span></span><br><span class="line"><span class="type">int</span> idx = it - st.<span class="built_in">begin</span>(); <span class="comment">// 错误！不可相减得到下标。</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 map"></a>映射 <a href="https://zh.cppreference.com/w/cpp/container/map">map</a></h2><p><strong><code>include &lt;map&gt;</code></strong><br>提供对数时间的有序键值对结构。底层原理是红黑树。</p><div class="table-container"><table><thead><tr><th>性质</th><th>解释</th><th>map</th><th>multimap</th><th>unordered_map</th></tr></thead><tbody><tr><td>互异性</td><td>一个键仅可以在映射中出现一次</td><td>✔</td><td>❌（任意次）</td><td>✔</td></tr><tr><td>无序性</td><td>键是没有顺序的</td><td>❌（从小到大）</td><td>❌（从小到大）</td><td>✔</td></tr></tbody></table></div><h3 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="构造-3"><a href="#构造-3" class="headerlink" title="构造"></a>构造</h4><p><strong><code>map&lt;键类型, 值类型, 比较器&gt; mp</code></strong></p><ul><li>键类型：要储存键的数据类型</li><li>值类型：要储存值的数据类型</li><li>比较器：键比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp1;               <span class="comment">// int-&gt;int 的映射（键从小到大）</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; st2; <span class="comment">// int-&gt;int 的映射（键从大到小）</span></span><br></pre></td></tr></table></figure><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4>可使用迭代器进行遍历：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>基于范围的循环（C++ 11）：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pr : mp)</span><br><span class="line">    cout &lt;&lt; pr.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pr.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>结构化绑定 + 基于范围的循环（C++17）：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[key, val] : mp)</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4></li></ul><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>增 / 改 / 查元素</td><td>中括号</td><td><code>mp[1] = 2;</code></td></tr><tr><td>查元素（返回迭代器）</td><td><code>.find(元素)</code></td><td><code>auto it = mp.find(1);</code></td></tr><tr><td>删除元素</td><td><code>.erase(元素)</code></td><td><code>mp.erase(2);</code></td></tr><tr><td>判断元素是否存在</td><td><code>.count(元素)</code></td><td><code>mp.count(3);</code></td></tr><tr><td>查看大小 / 清空 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">m[<span class="number">1</span>]=<span class="number">8</span>;</span><br><span class="line">m[<span class="number">7</span>]=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [key,val]:m)</span><br><span class="line">cout&lt;&lt;key&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;val&lt;&lt;endl;</span><br><span class="line">m[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [key,val]:m)</span><br><span class="line">cout&lt;&lt;key&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;val&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>如果使用中括号访问 map 时对应的键不存在，那么会新增这个键，并且值为默认值，因此中括号会影响键的存在性。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">count</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>];                       <span class="comment">// 即使什么都没做，此时mp[&#x27;a&#x27;]=0已经插入了</span></span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">count</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; mp[<span class="string">&#x27;a&#x27;</span>] &lt;&lt; endl;       <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p><h1 id="迭代器简介"><a href="#迭代器简介" class="headerlink" title="迭代器简介"></a>迭代器简介</h1><h2 id="迭代器是什么？"><a href="#迭代器是什么？" class="headerlink" title="迭代器是什么？"></a>迭代器是什么？</h2><p>对于一个 vector，我们可以用下标遍历：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><br>我们同时也可以用迭代器来遍历：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p><ul><li><code>a.begin()</code> 是一个迭代器，指向的是第一个元素</li><li><code>a.end()</code> 是一个迭代器，指向的是最后一个元素<strong>再后面一位</strong></li><li>上述迭代器具有自增运算符，自增则迭代器向下一个元素移动</li><li>迭代器与指针相似，如果对它使用解引用运算符，即 <code>*it</code>，就能取到对应值了</li></ul><h2 id="迭代器用法"><a href="#迭代器用法" class="headerlink" title="迭代器用法"></a>迭代器用法</h2><ul><li><code>.begin()</code>：头迭代器</li><li><code>.end()</code>：尾迭代器</li><li><code>.rbegin()</code>：反向头迭代器</li><li><code>.rend()</code>：反向尾迭代器</li><li>迭代器 <code>+</code> 整型：将迭代器向后移动</li><li>迭代器 <code>-</code> 整型：将迭代器向前移动</li><li>迭代器 <code>++</code>：将迭代器向后移动 1 位</li><li>迭代器 <code>--</code>：将迭代器向前移动 1 位</li><li>迭代器 <code>-</code> 迭代器：两个迭代器的距离</li><li><code>prev(it)</code>：返回 it 的前一个迭代器</li><li><code>next(it)</code>：返回 it 的后一个迭代器</li></ul><h2 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound() / upper_bound()"></a><code>lower_bound()</code> / <code>upper_bound()</code></h2><p>在<strong>已升序排序</strong>的元素中，应用二分查找检索指定元素，返回对应元素迭代器位置。<strong>找不到则返回尾迭代器。</strong></p><ul><li><code>lower_bound()</code>: 寻找大于等于x的第一个元素的位置</li><li><code>upper_bound()</code>: 寻找小于等于x的第一个元素的位置<br>返回的是迭代器，如何转成下标索引呢？减去头迭代器即可。<br><strong>用法示例</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value )</span></span>;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>);</span><br><span class="line"><span class="type">int</span> idx = it - arr.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// idx = 4</span></span><br></pre></td></tr></table></figure><p>我们通常写成一行：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>&#125;;</span><br><span class="line">idx = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">8</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">upper_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">upper_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">8</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间翻转区间异或和</title>
      <link href="/2026/02/05/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/16.%E5%8C%BA%E9%97%B4%E7%BF%BB%E8%BD%AC%E5%8C%BA%E9%97%B4%E5%BC%82%E6%88%96%E5%92%8C/"/>
      <url>/2026/02/05/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/16.%E5%8C%BA%E9%97%B4%E7%BF%BB%E8%BD%AC%E5%8C%BA%E9%97%B4%E5%BC%82%E6%88%96%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>符卡有一个长度为 $n$ 的整数数组 $a$，符卡认为一个区间 $[l, r]$ 是灵异区间当且仅当 $\bigoplus_{i=l}^r a_i = 0$，或者说这个区间内所有数字异或起来刚好等于 $0$。<br>符卡有特殊的魔法，可以把任意一个灵异区间翻转。具体来说，如果 $[l, r]$ 区间是灵异区间，那么符卡就可以对这个区间使用魔法，整个数组就会变成 $a_1, a_2, \dots, a_{l-1}, a_r, a_{r-1}, \dots, a_l, a_{r+1}, a_{r+2}, \dots, a_n$。<br>现在符卡可以使用任意次数的魔法，符卡希望最后得到的数组的灵异区间数量能够尽可能多，你能告诉她最后最多有多少个灵异区间吗？</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个正整数 $n$，表示数组长度。<br>第二行 $n$ 个非负整数 $a_1, a_2, \dots, a_n$ 表示整个数组。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行一个整数，表示符卡使用任意次魔法后灵异区间最多有多少个。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><p><strong>输入 #1</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure><br><strong>输出 #1</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><br><strong>输入 #2</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3 1 2 3</span><br></pre></td></tr></table></figure><br><strong>输出 #2</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p><p>对于如何找到灵异区间我们前面说到过,对整个数组求前缀异或,如果一个区间左右两端的数相等那么这段区间异或和为0。现在对于每个灵异区间要对它翻转,我们要考虑翻转过后对整个数组的应该。每个灵异区间的位置有三种可能。第一种:一个灵异完整地包裹在另一个灵异区间里面,第二种:一个灵异区间部分地包裹在另一个灵异区间里面,第三种:一个灵异区间独立存在,不与其他灵异区间相交。<br><img src="/img/9.png" alt="9"><br>所以灵异区间翻转不会产生新的灵异区间或者使灵异区间减少,所以只用统计灵异区间的个数,不用考虑翻转<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,sum=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">arr</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">        arr[i]^=arr[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:arr)</span><br><span class="line">    cnt[x]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[_,c]:cnt)</span><br><span class="line">    sum+=c*(c<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K倍区间</title>
      <link href="/2026/02/05/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/17.K%E5%80%8D%E5%8C%BA%E9%97%B4/"/>
      <url>/2026/02/05/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/17.K%E5%80%8D%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="k倍区间"><a href="#k倍区间" class="headerlink" title="k倍区间"></a>k倍区间</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个长度为 $N$ 的数列， $A_1, A_2, \cdots A_N$。如果其中一段连续的子序列 $A_i, A_{i+1}, \cdots A_j (i \le j)$ 之和是 $K$ 的倍数，我们就称这个区间 $[i, j]$ 是 K 倍区间。<br>你能求出数列中总共有多少个 $K$ 倍区间吗？</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>第一行包含两个整数 $N$ 和 $K$ $(1 \le N, K \le 10^5)$。<br>以下 $N$ 行每行包含一个整数 $A_i$ $(1 \le A_i \le 10^5)$。</p><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>输出一个整数，代表 K 倍区间的数目。</p><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p><strong>示例</strong><br><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5 2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/img/8.png" alt="8"></p><ul><li><strong>前缀和</strong>：计算数组的前缀和 $S$。</li><li><strong>同余定理</strong>：如果区间 $[i, j]$ 的和是 $K$ 的倍数，即 $(S_j - S_{i-1}) \% K == 0$，这意味着 $S_j \% K == S_{i-1} \% K$。</li><li><strong>转化</strong>：只需要计算前缀和模 $K$ 的余数。如果有 $c$ 个前缀和的余数相同（比如都是 1），那么从这 $c$ 个位置中任选 2 个（$C_c^2$），它们之间的区间和就是 $K$ 的倍数。</li></ul><p>```cpp</p><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<vector></h1><p>using namespace std;<br>int main()<br>{<br>    int N,K,sum=0;<br>    cin&gt;&gt;N&gt;&gt;K;<br>    vector<int>arr(N+1,0);<br>    vector<int>cnt(K,0);<br>    for(int i=1;i&lt;=N;i++)<br>    cin&gt;&gt;arr[i];<br>    for(int i=1;i&lt;=N;i++)<br>    arr[i]=(arr[i-1]+arr[i])%K;<br>    for(auto &amp;x:arr)<br>    cnt[x]++;<br>    for(auto &amp;c:cnt)<br>    sum+=(c-1)*c/2;<br>    cout&lt;&lt;sum;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拔河</title>
      <link href="/2026/02/05/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/18.%E6%8B%94%E6%B2%B3/"/>
      <url>/2026/02/05/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/18.%E6%8B%94%E6%B2%B3/</url>
      
        <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>小明是学校里的一名老师，他带的班级共有 $n$ 名同学，第 $i$ 名同学力量值为 $a_i$。在闲暇之余，小明决定在班级里组织一场拔河比赛。<br>为了保证比赛双方实力尽可能相近，需要在这 $n$ 名同学中挑选出两个队伍，队伍内的同学编号连续：${a_{l_1}, a_{l_1+1}, \dots, a_{r_1}}$ 和 ${a_{l_2}, a_{l_2+1}, \dots, a_{r_2}}$，其中 $l_1 \le r_1 &lt; l_2 \le r_2$。<br>两个队伍的人数不必相同，但是需要让队伍内的同学们的力量值之和尽可能相近。请计算出力量值之和差距最小的挑选队伍的方式。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共两行。<br>第一行为一个正整数 $n$。<br>第二行为 $n$ 个正整数 $a_i$。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共一行，一个非负整数，表示两个队伍力量值之和的最小差距。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">10 9 8 12 14</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h4><p>其中一种最优选择方式：<br>队伍 1：${a_1, a_2, a_3}$，队伍 2：${a_4, a_5}$，力量值和分别为 $10+9+8=27$，$12+14=26$，差距为 $|27-26|=1$。</p><p><img src="/img/7.png" alt="7"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,ans=<span class="number">9999999</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">arr</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    arr[i]+=arr[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r1=n<span class="number">-1</span>;r1&gt;=<span class="number">1</span>;r1--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=r1<span class="number">+1</span>;i&lt;=n;i++)</span><br><span class="line">        s.<span class="built_in">insert</span>(arr[i]-arr[r1]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l1=<span class="number">1</span>;l1&lt;=r1;l1++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left_sum=arr[r1]-arr[l1<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">// 3. 在 Set 里找最接近 left_sum 的值</span></span><br><span class="line">            <span class="comment">// lower_bound 找到第一个 &gt;= left_sum 的位置</span></span><br><span class="line">            <span class="keyword">auto</span> it = s.<span class="built_in">lower_bound</span>(left_sum);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 情况 A: 找到了 &gt;= left_sum 的值，算一下差值</span></span><br><span class="line">            <span class="keyword">if</span> (it != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(*it - left_sum));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 情况 B: 它前面的那个值（即 &lt; left_sum 的最大值），也要算一下</span></span><br><span class="line">            <span class="comment">// 因为最接近的值可能是比它大的，也可能是比它小的</span></span><br><span class="line">            <span class="keyword">if</span> (it != s.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> prev_it = <span class="built_in">prev</span>(it); <span class="comment">// 获取迭代器的前一个位置</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(*prev_it - left_sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挖矿</title>
      <link href="/2026/02/03/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/14.%E6%8C%96%E7%9F%BF/"/>
      <url>/2026/02/03/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/14.%E6%8C%96%E7%9F%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>小蓝正在数轴上挖矿，数轴上一共有 $n$ 个矿洞，第 $i$ 个矿洞的坐标为 $a_i$。小蓝从 $0$ 出发，每次可以向左或向右移动 $1$ 的距离。当路过一个矿洞时，就会进行挖矿作业，获得 $1$ 单位矿石。但一个矿洞不能被多次挖掘。小蓝想知道在移动距离不超过 $m$ 的前提下，最多能获得多少单位矿石？</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含两个正整数 $n, m$，用一个空格分隔。<br>第二行包含 $n$ 个整数 $a_1, a_2, \cdots, a_n$，相邻整数之间使用一个空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行包含一个整数表示答案。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>Plaintext<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">0 -3 -1 1 2</span><br></pre></td></tr></table></figure></p><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>Plaintext<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>路径：$0 \to -1 \to 0 \to 1 \to 2$，可以对 $0, -1, 1, 2$ 四个矿洞挖掘并获得最多 $4$ 块矿石。<br>_(注：距离计算为 $0 \to -1$ (1) $\to 0$ (1) $\to 1$ (1) $\to 2$ (1)，总距离 4，不超过 $m=4$)_</p><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><p>对于 $20\%$ 的评测用例，$1 \le n \le 10^3$。<br>对于所有评测用例，$1 \le n \le 10^5$，$-10^6 \le a_i \le 10^6$，$1 \le m \le 2 \times 10^6$。</p><p>枚举尽可能往左走和尽可能往右走的情况<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_COORD = <span class="number">2000005</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">arr</span>(<span class="number">4000011</span>,<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> minlocation=<span class="number">2000005</span>,maxlocation=<span class="number">2000005</span>,lmaxvalue=<span class="number">0</span>,rmaxvalue=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        arr[a+MAX_COORD]+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4000010</span>;i++)</span><br><span class="line">        arr[i]+=arr[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((arr[MAX_COORD]-arr[MAX_COORD -i<span class="number">-1</span>]+arr[MAX_COORD+m<span class="number">-2</span>*i]-arr[MAX_COORD])&gt;lmaxvalue)</span><br><span class="line">            lmaxvalue=arr[MAX_COORD]-arr[MAX_COORD -i<span class="number">-1</span>]+arr[MAX_COORD+m<span class="number">-2</span>*i]-arr[MAX_COORD];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">if</span>((arr[MAX_COORD+i]-arr[MAX_COORD<span class="number">-1</span>]+arr[MAX_COORD<span class="number">-1</span>]-arr[MAX_COORD-m<span class="number">+2</span>*i<span class="number">-1</span>])&gt;rmaxvalue)</span><br><span class="line">            rmaxvalue=arr[MAX_COORD+i]-arr[MAX_COORD<span class="number">-1</span>]+arr[MAX_COORD<span class="number">-1</span>]-arr[MAX_COORD-m<span class="number">+2</span>*i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">max</span>(lmaxvalue,rmaxvalue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抓娃娃</title>
      <link href="/2026/02/03/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/15.%E6%8A%93%E5%A8%83%E5%A8%83/"/>
      <url>/2026/02/03/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/15.%E6%8A%93%E5%A8%83%E5%A8%83/</url>
      
        <content type="html"><![CDATA[<h3 id="题目名称：抓娃娃"><a href="#题目名称：抓娃娃" class="headerlink" title="题目名称：抓娃娃"></a>题目名称：抓娃娃</h3><p><strong>【问题描述】</strong><br>小明拿了 $n$ 条线段练习抓娃娃。他将所有线段铺在数轴上，第 $i$ 条线段的左端点在 $l_i$，右端点在 $r_i$。<br>小明用 $m$ 个区间去框这些线段，第 $i$ 个区间的范围是 $[L_i, R_i]$。<br>如果一个线段有 <strong>至少一半</strong> 的长度被包含在某个区间内，则将其视为被这个区间框住。<br>请计算出每个区间框住了多少个线段？<br><strong>【输入格式】</strong><br>输入共 $n+m+1$ 行。<br>第一行为两个正整数 $n, m$。<br>后面 $n$ 行，每行两个整数 $l_i, r_i$。<br>后面 $m$ 行，每行两个整数 $L_i, R_i$。<br><strong>【输出格式】</strong><br>输出共 $m$ 行，每行一个整数。<br><strong>【样例输入】</strong><br>Plaintext<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">3 4</span><br><span class="line">1 4</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><br><strong>【样例输出】</strong><br>Plaintext<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p><strong>【评测用例规模与约定】</strong><br>对于 $20\%$ 的数据，保证 $n, m \le 10^3$。<br>对于 $100\%$ 的数据，保证 $n, m \le 10^5$， $l_i &lt; r_i$，$0 &lt; l_i, r_i, L_i, R_i \le 10^6$，$\max{r_i - l_i} \le \min{R_i - L_i}$。</p><p>$\max{r_i - l_i} \le \min{R_i - L_i}$。<br>这个条件说明所有线段的长度都小于或等于区间的长度<br>一个线段一半要被区间包住,说明线段的中点要在区间的范围里面。<br>要计算一个区间里面可以包住多少线段就转化成了有多少线段中点在区间里面。<br>由于l和r取中点可能为小数,我们将范围扩大两倍则中点就为l+r,就不能担心小数问题了。同样要注释咱们包住区间的范围也要扩大两倍<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_COORD = <span class="number">2000005</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">arr</span>(MAX_COORD,<span class="number">0</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">result</span>(MAX_COORD,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        arr[a+b]+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=MAX_COORD;i++)</span><br><span class="line">    arr[i]+=arr[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        result[i]=arr[<span class="number">2</span>*b]-arr[<span class="number">2</span>*a<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    cout&lt;&lt;result[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🚀 本站博客搭建与美化技术文档</title>
      <link href="/2026/02/02/Hexo%E5%BB%BA%E7%AB%99/%F0%9F%9A%80%20%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%BE%8E%E5%8C%96%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
      <url>/2026/02/02/Hexo%E5%BB%BA%E7%AB%99/%F0%9F%9A%80%20%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%BE%8E%E5%8C%96%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="🚀-本站博客搭建与美化技术文档"><a href="#🚀-本站博客搭建与美化技术文档" class="headerlink" title="🚀 本站博客搭建与美化技术文档"></a>🚀 本站博客搭建与美化技术文档</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>本站基于 <strong>Hexo</strong> 静态博客框架搭建，使用了功能强大的 <strong>Butterfly</strong> 主题。本文档记录了从零开始搭建、配置主题以及进行个性化美化的完整过程，既是对自己折腾过程的记录，也希望能帮助到想搭建类似博客的朋友。</p><h2 id="2-技术栈概览"><a href="#2-技术栈概览" class="headerlink" title="2. 技术栈概览"></a>2. 技术栈概览</h2><ul><li><p><strong>核心框架</strong>: <a href="https://hexo.io/zh-cn/">Hexo</a> (快速、简洁且高效的博客框架)</p></li><li><p><strong>博客主题</strong>: <a href="https://butterfly.js.org/">Butterfly</a> (一款美观且功能丰富的 Hexo 主题)</p></li><li><p><strong>托管平台</strong>: GitHub Pages (免费、稳定的静态网页托管)</p></li><li><p><strong>评论系统</strong>: Giscus (基于 GitHub Discussions 的评论系统)</p></li><li><p><strong>统计工具</strong>: 不蒜子 (Busuanzi)</p></li></ul><h2 id="3-基础环境搭建"><a href="#3-基础环境搭建" class="headerlink" title="3. 基础环境搭建"></a>3. 基础环境搭建</h2><p>参考教程：<a href="https://blog.csdn.net/mjh1667002013/article/details/129064188">【Hexo搭建】免费快速搭建Hexo博客网站并部署上线</a></p><p>我的搭建流程主要分为以下几步：</p><ol><li><p><strong>环境准备</strong>: 安装 Node.js 和 Git，这是 Hexo 运行的基础。</p></li><li><p><strong>初始化博客</strong>: 使用 <code>npm install -g hexo-cli</code> 安装脚手架，并通过 <code>hexo init</code> 生成博客目录。</p></li><li><p><strong>部署设置</strong>: 在 GitHub 创建仓库（<code>用户名.github.io</code>），安装 <code>hexo-deployer-git</code> 插件，实现一键部署 (<code>hexo d</code>)。</p></li></ol><h2 id="4-主题安装与配置"><a href="#4-主题安装与配置" class="headerlink" title="4. 主题安装与配置"></a>4. 主题安装与配置</h2><p>参考教程：<a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">【Hexo】Hexo搭建Butterfly主题并快速美化</a></p><p>为了让博客更美观，我选择了 Butterfly 主题。</p><ul><li><p><strong>安装</strong>: 通过 <code>git clone</code> 下载主题文件到 <code>themes/butterfly</code> 目录。</p></li><li><p><strong>配置策略</strong>: 为了方便后续升级，我采用了“覆盖配置”的方式。即在博客根目录新建 <code>_config.butterfly.yml</code> 文件，专门存放主题的配置项，它会覆盖主题自带的 <code>_config.yml</code>。</p></li></ul><h2 id="5-本站特色功能配置"><a href="#5-本站特色功能配置" class="headerlink" title="5. 本站特色功能配置"></a>5. 本站特色功能配置</h2><p>基于我的 <code>_config.butterfly.yml</code> 文件，本站开启了以下个性化功能：</p><h3 id="5-1-视觉美化"><a href="#5-1-视觉美化" class="headerlink" title="5.1 视觉美化"></a>5.1 视觉美化</h3><ul><li><p><strong>背景特效</strong>: 开启了 <code>canvas_nest</code>（动态线条背景）和 <code>fireworks</code>（鼠标点击烟花特效），增加页面的交互感。</p></li><li><p><strong>看板娘 (Live2D)</strong>: 在页面右下角添加了 Live2D 看板娘挂件，并配置了自定义 CSS 将工具栏调整至左侧，避免遮挡。</p><p>YAML</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 注入的自定义 CSS</span><br><span class="line">#waifu &#123; left: auto; right: 10px; &#125;</span><br><span class="line">#waifu-tool &#123; right: auto; left: -35px; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-2-音乐播放器-APlayer"><a href="#5-2-音乐播放器-APlayer" class="headerlink" title="5.2 音乐播放器 (APlayer)"></a>5.2 音乐播放器 (APlayer)</h3><p>为了让访问者有更好的听觉体验，我集成了 APlayer 全局播放器：</p><ul><li><p><strong>歌单来源</strong>: 网易云音乐 (周杰伦精选集)</p></li><li><p><strong>配置方式</strong>: 通过 <code>inject</code> 在页面底部注入 MetingJS 脚本，实现了迷你模式的左下角播放器。</p><p>HTML</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meting-js   server=&quot;netease&quot;   type=&quot;playlist&quot;   id=&quot;3136952023&quot;   mini=&quot;true&quot;   fixed=&quot;true&quot;&gt;</span><br><span class="line">&lt;/meting-js&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-3-交互与功能"><a href="#5-3-交互与功能" class="headerlink" title="5.3 交互与功能"></a>5.3 交互与功能</h3><ul><li><p><strong>评论系统</strong>: 选用了 <strong>Giscus</strong>，访客可以使用 GitHub 账号登录评论，数据直接存储在 GitHub 仓库的 Discussions 中，安全且无广告。</p></li><li><p><strong>搜索功能</strong>: 开启了 <strong>Local Search</strong>，支持对站内文章的快速检索。</p></li><li><p><strong>数据统计</strong>: 集成了 <strong>不蒜子</strong> 统计，在页脚和侧边栏显示网站的访问量 (PV) 和访客数 (UV)。</p></li></ul><h2 id="6-常用维护命令"><a href="#6-常用维护命令" class="headerlink" title="6. 常用维护命令"></a>6. 常用维护命令</h2><ul><li><p><code>hexo clean</code>: 清除缓存</p></li><li><p><code>hexo g</code>: 生成静态网页 (Generate)</p></li><li><p><code>hexo s</code>: 本地预览 (Server)</p></li><li><p><code>hexo d</code>: 部署到 GitHub (Deploy)</p></li></ul><hr><blockquote><p><strong>致谢</strong>: 感谢博主 [小满@] 提供的详细教程，让我在搭建过程中少走了很多弯路。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接雨水</title>
      <link href="/2026/02/01/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/13.%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2026/02/01/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/13.%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<p>题目描述<br>给定 $n$ 个非负整数表示每个柱子的高度，每个柱子的宽度为 1，计算按此排列的柱子，下雨之后能接多少雨水。<br>输入格式</p><ul><li>第一行包含一个整数 $n$，表示柱子的数量。</li><li>接下来的 $n$ 行（或一行内），每行一个非负整数，表示每个位置柱子的高度 $height[i]$。<br>输出格式</li><li>输出一个整数，表示能够接住的雨水总量。</li></ul><p><img src="/img/10.png" alt="10"><br>对于每一个单位的我们只需要找到它左边的最大值和右边的最大值,取二者的最小值,再减去这个单位的柱子长度。<br>用前缀最大值数组存储左边最大值,后缀最大值数组存储右边最大值<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,sum=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> arr[n<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="type">int</span> left_max[n<span class="number">+1</span>];</span><br><span class="line">    <span class="type">int</span> right_max[n<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">        left_max[i]=arr[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            left_max[i]=<span class="built_in">max</span>(arr[i],left_max[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==n)</span><br><span class="line">        right_max[i]=arr[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right_max[i]=<span class="built_in">max</span>(arr[i],right_max[i<span class="number">+1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span>(right_max[i],left_max[i])&lt;=arr[i])</span><br><span class="line">        sum+=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        sum+=<span class="built_in">min</span>(right_max[i],left_max[i])-arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/img/11.png" alt="11"><br>先找到最高的柱子,对它左边的每个柱子,用它左侧的最大高度减去自身高度,对它右边的每个柱子,<br>用它右侧的最大高度减去自身高度。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="type">int</span> n,sum=<span class="number">0</span>,index=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> arr[n<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="type">int</span> maxhigh=arr[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;maxhigh)</span><br><span class="line">        &#123;</span><br><span class="line">            maxhigh=arr[i];</span><br><span class="line">            index=i;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> maxleft=arr[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;index;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;maxleft)</span><br><span class="line">        maxleft=arr[i];</span><br><span class="line">        sum+=maxleft-arr[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxright=arr[n]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;index;i--) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;maxright)</span><br><span class="line">        maxright=arr[i];</span><br><span class="line">        sum+=maxright-arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光骓者的荣耀</title>
      <link href="/2026/02/01/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/11.%E5%85%89%E9%AA%93%E8%80%85%E7%9A%84%E8%8D%A3%E8%80%80/"/>
      <url>/2026/02/01/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/11.%E5%85%89%E9%AA%93%E8%80%85%E7%9A%84%E8%8D%A3%E8%80%80/</url>
      
        <content type="html"><![CDATA[<p>小 K 打下的江山一共有 $n$ 个城市，城市 $i$ 和城市 $i+1$ 有一条双向高速公路连接，走这条路要耗费时间 $a_i$。小 K 为了关心人民生活，决定定期进行走访。他每一次会从 $1$ 号城市到 $n$ 号城市并在经过的城市进行访问。其中终点必须为城市 $n$。<br>不仅如此，他还有一个传送器，传送半径为 $k$，也就是说可以传送到 $i-k$ 和 $i+k$。如果目标城市编号小于 $1$ 则为 $1$，大于 $n$ 则为 $n$。<br>但是他的传送器电量不足，<strong>只能传送一次</strong>，况且由于一些原因，他想尽量快地完成访问，于是就想问交通部部长您最快的时间是多少。<br><strong>注意：</strong> 他可以不访问所有的城市，使用传送器不耗费时间。</p><hr><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h3><ul><li><strong>两行</strong>：第一行包含两个整数 $n, k$。</li><li><strong>第二行</strong>：包含 $n-1$ 个整数，第 $i$ 个整数表示 $a_i$（即城市 $i$ 到 $i+1$ 之间的耗时）。</li></ul><hr><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h3><ul><li>输出一个整数，表示从 $1$ 号城市到 $n$ 号城市的最短时间。</li></ul><p>我们想要尽可能的少走,传送的距离尽可能的多<br>用一个数组存储相邻两个城市之间的距离然后计算这个数组的前缀和,计算arr[i+k]-arr[i]的最大值,就可以找到传送的最大距离,以及对应的传送点i<br>用总距离减去这个传送的最大距离就可以得到最短路程<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k,maxdistance=<span class="number">0</span>,maxstation=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;=n<span class="number">-1</span>)</span><br><span class="line">    cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="type">int</span> prefix[n];</span><br><span class="line">    prefix[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    cin&gt;&gt;prefix[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">    prefix[i]+=prefix[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prefix[i+k]-prefix[i]&gt;maxdistance)</span><br><span class="line">        &#123;</span><br><span class="line">            maxdistance=prefix[i+k]-prefix[i];</span><br><span class="line">            maxstation=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxstation&lt;&lt;endl&lt;&lt;prefix[n<span class="number">-1</span>]-maxdistance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>领地选择</title>
      <link href="/2026/02/01/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/12.%E9%A2%86%E5%9C%B0%E9%80%89%E6%8B%A9/"/>
      <url>/2026/02/01/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/12.%E9%A2%86%E5%9C%B0%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<p>作为在虚拟世界里统帅千军万马的领袖，小 Z 认为天时、地利、人和三者是缺一不可的。所以，谨慎地选择首都的位置对于小 Z 来说是非常重要的。<br>首都都被认为是一个占地 $C \times C$ 的正方形。小 Z 希望你找到一个合适的位置，使得首都所占领的位置的土地价值总和最高。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h3><ul><li>第一行三个整数 $N, M, C$，表示地图的宽和长以及首都的边长。</li><li>接下来 $N$ 行每行 $M$ 个整数，表示地图上每个地块的价值。价值可能为负数。<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h3></li><li>一行两个整数 $X, Y$，表示首都左上角的坐标。<h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a><strong>输入输出样例</strong></h3></li><li><strong>输入 #1</strong>：<br>  Plaintext  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 2</span><br><span class="line">1 2 3 1</span><br><span class="line">-1 9 0 2</span><br><span class="line">2 0 1 1</span><br></pre></td></tr></table></figure></li><li><strong>输出 #1</strong>：<br>  Plaintext  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure></li></ul><p>二维前缀和<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M,C,X,Y,MAXVAULE=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;C;</span><br><span class="line">    <span class="type">int</span> arr[N<span class="number">+1</span>][M<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=M;i++)</span><br><span class="line">    arr[<span class="number">0</span>][i]=<span class="number">-2e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=N;i++)</span><br><span class="line">    arr[i][<span class="number">0</span>]=<span class="number">-2e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=M;j++)</span><br><span class="line">        cin&gt;&gt;arr[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=M;j++)</span><br><span class="line">        arr[i][j]+=arr[i][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=M;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;j&lt;=N;j++)</span><br><span class="line">        arr[i][j]+=arr[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=C;j&lt;=M;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j]-arr[i][j-C]-arr[i-C][j]+arr[i+C][j+C]&gt;MAXVAULE)</span><br><span class="line">            &#123;</span><br><span class="line">                MAXVAULE=arr[i][j]-arr[i][j-C]-arr[i-C][j]+arr[i+C][j+C];</span><br><span class="line">                X=i-C<span class="number">+1</span>,Y=j-C<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;X&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>弹珠堆放</title>
      <link href="/2026/01/31/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/10.%E5%BC%B9%E7%8F%A0%E5%A0%86%E6%94%BE/"/>
      <url>/2026/01/31/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/10.%E5%BC%B9%E7%8F%A0%E5%A0%86%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<p> 小蓝有 20230610 颗弹珠，想摆成一个金字塔。<br>高度 1：1 颗<br>高度 2：4 颗<br>高度 3：10 颗<br>高度 4：20 颗<br>问：手里的弹珠最多能摆多高？                                                                                                                               ！<a href="/img/12.png">12</a><br>观察可知,从上往下,每层数量是以1为首项,公差为以2为首项1为公差的等差数列的等差数列<br>枚举每层数量相加即可<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pre=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> high=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sum&lt;=<span class="number">20230610</span>)&#123;</span><br><span class="line">        sum+=pre;</span><br><span class="line">        high+=<span class="number">1</span>;</span><br><span class="line">        pre=pre+high<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;high<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/img/13.png" alt="13"><br>这是每层的数量以及高度为N的总数量和前缀和的关系<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> prefix[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">    prefix[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=<span class="number">1000</span>;j++)</span><br><span class="line">    prefix[j]=prefix[j]+prefix[j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=<span class="number">1000</span>;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        prefix[k]=prefix[k]+prefix[k<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(prefix[k]&gt;<span class="number">20230610</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prefix[k]==<span class="number">20230610</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        cout&lt;&lt;k;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和</title>
      <link href="/2026/01/31/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/9.%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2026/01/31/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/9.%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>这是求一个一维数组的前缀和<br>如果我们要计算4-9这个区间的和我们就可以用prefix[9]-prefix[3]得到<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">prefix</span>(n)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i)prefix[i]=prefix[i<span class="number">-1</span>];</span><br><span class="line">prefix[i]+=arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异或的性质 :</p><ol><li>核心定义：相同为 0，不同为 1(从位的角度)</li><li>任何数和 0 异或，结果还是它自己</li><li>A ^(B^C)=(A^B)^ C</li><li>自己异或自己 = 0</li><li>A=B ^ C,两边^ C,A^ C=B<br>求前缀异或<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">prefix</span>(n)</span><br><span class="line">prefix[<span class="number">0</span>]=arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">prefix[i]^=prefix[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果我们要计算4-9这个区间的异或我们就可以用prefix[9]^ prefix[3]</li></ol><p>二维前缀和(在二维矩阵中求任意子矩阵的和)<br><img src="/img/14.png" alt="14"><br>比如12就代表的是左上角2 * 2区域的和<br><img src="/img/15.png" alt="15"></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好数</title>
      <link href="/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/1.%E5%A5%BD%E6%95%B0/"/>
      <url>/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/1.%E5%A5%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>一个整数如果按从低位到高位的顺序，奇数位（个位、百位、万位 · · · ）上的数字是奇数，偶数位（十位、千位、十万位 · · · ）上的数字是偶数，我们就称之为“好数”。给定一个正整数 N，请计算从 1 到 N 一共有多少个好数。</p><p>我的思路就是利用<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="type">int</span> dight = x % <span class="number">10</span>;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">x /=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>取它的每一位判断,但我怎么可以确定每一位是对应奇数位还是偶数位了?我无法确定,于是我就想到一种简单粗暴的方式,把从低位到高位的每一位取出来然后存放在数组中,用两个循环分别遍历数组的奇数位和偶数位,判断每一位是不是符合要求。于是就有了下面的代码。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsHaoShu</span><span class="params">(<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; arr1;</span><br><span class="line">   <span class="type">int</span> n;</span><br><span class="line">   <span class="keyword">while</span>(N)&#123;</span><br><span class="line">    n=N%<span class="number">10</span>;</span><br><span class="line">    arr<span class="number">1.</span><span class="built_in">push_back</span>(n);</span><br><span class="line">    N/=<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> flag1=<span class="number">1</span>,flag2=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=arr<span class="number">1.</span><span class="built_in">size</span>()<span class="number">-1</span>;i+=<span class="number">2</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr1[i]%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag1=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=arr<span class="number">1.</span><span class="built_in">size</span>()<span class="number">-1</span>;j+=<span class="number">2</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr1[j]%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">            flag2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(flag1 &amp;&amp; flag2)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsHaoShu</span>(k))</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>简单粗暴,时间复杂度为O(NlogN)<br>后来了就看到一种每次在while循环里面可以判断我所判断的这一位就是是要满足偶数位性质还是奇数位性质。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> index=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> dight=x%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(dight % <span class="number">2</span> != index % <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>很巧妙的运用到了一个index，它模2是一个1，0，1，0的循环序列,刚好对应奇数位为奇数模2余1,偶数位为偶数模2余0。还有几种写法,就是把index++改为index=1-index或者index ^=1。<br>优化后的代码为<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsHaoShu</span><span class="params">(<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> dight=N%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(dight % <span class="number">2</span>!=index % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        N /=<span class="number">10</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,count=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsHaoShu</span>(i))</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举算法入门</title>
      <link href="/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/0.%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/0.%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在某个可能的解的集合中,按某个顺序依次检索元素,用题目给定的条件进行校验和计算。<br>是否存在,找到第一个,全部都,全部都不。</p><p>原数组中是否存在子数组？(元素无需连续，但需保持相对顺序一致)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">templata&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">subMatch</span><span class="params">(<span class="type">const</span> T&amp;arr,<span class="type">const</span> T&amp;target)</span></span>&#123;</span><br><span class="line"><span class="type">size_t</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;elem : arr)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(elem==target[idx])</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(++idx == target.<span class="built_in">size</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>寻找第K小的素数?<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> idx=<span class="number">1</span>;;idx++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isPrime</span>(idx))</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(cnt==k)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;idx;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="枚举的优化-裁剪枚举集"><a href="#枚举的优化-裁剪枚举集" class="headerlink" title="枚举的优化:裁剪枚举集"></a>枚举的优化:裁剪枚举集</h2><p>判断一个数是否为素数?<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n%i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>根据数学特性可以缩小枚举范围<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n%i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按位枚举:<br> 比如枚举十进制数1234的每一位<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="type">int</span> dight = x % <span class="number">10</span>;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">x /=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 对于将十进制整数 <code>x</code> 转换为 <code>base</code> 进制的各位数字,把10改为对应的进制数<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr1;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="type">int</span> dight = x % base;</span><br><span class="line">arr<span class="number">1.</span><span class="built_in">push_back</span>(dight);</span><br><span class="line">x /=base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将 <code>base</code> 进制的逆序数字转换回十进制整数<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=arr<span class="number">1.</span><span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">  x = x * base +arr1[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>幸运数</title>
      <link href="/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/2.%E5%B9%B8%E8%BF%90%E6%95%B0/"/>
      <url>/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/2.%E5%B9%B8%E8%BF%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>小蓝认为如果一个数含有偶数个数位，并且前面一半的数位之和等于后面 一半的数位之和，则这个数是他的幸运数字。例如2314是一个幸运数字，因为 它有4个数位，并且2+3=1+4。现在请你帮他计算从1至100000000之间 共有多少个不同的幸运数字？</p><p>这道题思路比较简单,一个数对10取对数然后向上取整可以得到它的位数,对于位数为偶数的数,按位枚举,前一半相加后一半相加。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsLucky</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> m=<span class="built_in">log10</span>(n)<span class="number">+1</span>,sum1=<span class="number">0</span>,sum2=<span class="number">0</span>,index=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(m%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">while</span>(n)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">int</span> dight=n%<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">if</span>(index&gt;m/<span class="number">2</span>)</span><br><span class="line">      sum2+=dight;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      sum1+=dight;</span><br><span class="line">      n/=<span class="number">10</span>;</span><br><span class="line">      index++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum1==sum2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100000000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsLucky</span>(i))</span><br><span class="line">        sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡片</title>
      <link href="/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/3.%E5%8D%A1%E7%89%87/"/>
      <url>/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/3.%E5%8D%A1%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>小蓝有很多数字卡片，每张卡片上标有 0到9 中的一个数字。<br>他想用这些卡片从 1 开始拼出连续的正整数，每拼一个数，就把用到的卡片保存起来，之后不能再用这些卡片拼其他数。<br>例如，如果小蓝手里有 30 张卡片，每个数字 0到9 各 3 张，他可以拼出 1到10，但是拼 11 时，数字 1 的卡片已经不够用了。<br>现在，小蓝手里有每个数字 0到9 的卡片各 2021 张（总共 20210 张），问他能够从 1 拼到的最大连续整数是多少？<br>这道题的思路也很简单,咱们准备一个十个空间大小的数组vec[10],都存储2021,代表0~9的卡片都有2021张,遍历从1开始的数,我们将它逐位分解,对于分解出的每一位x,vec[x]—，直到某个数分解出的某位i,vec[i]=0时,说明没有卡片去给它组成这个数了，那么答案就是这个数的上一个数。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>,<span class="number">2021</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> re=i;</span><br><span class="line">        <span class="keyword">while</span>(re)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> index=re%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(vec[index]==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">            vec[index]--;</span><br><span class="line">            re/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">work</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找2020</title>
      <link href="/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/4.%E5%AF%BB%E6%89%BE2020/"/>
      <url>/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/4.%E5%AF%BB%E6%89%BE2020/</url>
      
        <content type="html"><![CDATA[<p>给定一个 n×n 的二维数组，数组中的每个元素都是 <code>0</code> 或 <code>2</code>。请你统计数组中<strong>连续的四个元素</strong>恰好组成 <code>2020</code> 的序列个数。<br>连续序列的方向限定为以下 <strong>4 种</strong>：</p><ol><li><strong>水平向右</strong>：同一行中，从左到右连续 4 个元素</li><li><strong>竖直向下</strong>：同一列中，从上到下连续 4 个元素</li><li><strong>主对角线向下</strong>：左上到右下方向，连续 4 个元素</li><li><strong>副对角线向下</strong>：右上到左下方向，连续 4 个元素<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3></li><li>第一行输入一个整数 n（4≤n≤1000），表示二维数组的行数和列数</li><li>接下来 n 行，每行输入一个长度为 n 的字符串，字符串仅由 <code>0</code> 和 <code>2</code> 组成<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3>输出一个整数，表示满足条件的 <code>2020</code> 序列的总个数</li></ol><p>这道题目刚开始我理解的意思时,一个序列的四个元素只能用一次,下一次寻找的序列的元素要是没有被选中过的,这种想法应该有很多不一样的答案。<br>这道题的意思其实时找出所有可能不考虑是否构成序列的元素是否被用过。<br>我们只需要遍历每一个元素,看它在这四种序列方向上是否可以构成一个2020序列。在遍历时可以简化枚举次数。<br>比如一个n*n的二维数组,(i,j)处的数要构成横向的2020则必须要j+3&lt;=n，同理要构成竖向的2020要满足i+3&lt;=n,构成主对角线向下的2020则必须要满足i+3&lt;=n&amp;&amp;j+3&lt;=n，构成副对角线向下的2020则必须要满足i+3&lt;=n&amp;&amp;j-3&gt;=1<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,cnt=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">arr</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string a;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        arr[i][j]=a[j<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">if</span>(j<span class="number">+3</span>&lt;=n&amp;&amp;arr[i][j]==<span class="number">2</span>&amp;&amp;arr[i][j<span class="number">+1</span>]==<span class="number">0</span>&amp;&amp;arr[i][j<span class="number">+2</span>]==<span class="number">2</span>&amp;&amp;arr[i][j<span class="number">+3</span>]==<span class="number">0</span>)</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">+3</span>&lt;=n&amp;&amp;arr[i][j]==<span class="number">2</span>&amp;&amp;arr[i<span class="number">+1</span>][j]==<span class="number">0</span>&amp;&amp;arr[i<span class="number">+2</span>][j]==<span class="number">2</span>&amp;&amp;arr[i<span class="number">+3</span>][j]==<span class="number">0</span>)</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">+3</span>&lt;=n&amp;&amp;j<span class="number">+3</span>&lt;=n&amp;&amp;arr[i][j]==<span class="number">2</span>&amp;&amp;arr[i<span class="number">+1</span>][j<span class="number">+1</span>]==<span class="number">0</span>&amp;&amp;arr[i<span class="number">+2</span>][j<span class="number">+2</span>]==<span class="number">2</span>&amp;&amp;arr[i<span class="number">+3</span>][j<span class="number">+3</span>]==<span class="number">0</span>)</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(j<span class="number">-3</span>&gt;=<span class="number">1</span>&amp;&amp;i<span class="number">+3</span>&lt;=n&amp;&amp;arr[i][j]==<span class="number">2</span>&amp;&amp;arr[i<span class="number">+1</span>][j<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;arr[i<span class="number">+2</span>][j<span class="number">-2</span>]==<span class="number">2</span>&amp;&amp;arr[i<span class="number">+3</span>][j<span class="number">-3</span>]==<span class="number">0</span>)</span><br><span class="line">            cnt++;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小球反弹</title>
      <link href="/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/5.%E5%B0%8F%E7%90%83%E5%8F%8D%E5%BC%B9/"/>
      <url>/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/5.%E5%B0%8F%E7%90%83%E5%8F%8D%E5%BC%B9/</url>
      
        <content type="html"><![CDATA[<p>有一长方形，长为 343720 单位长度，宽为 233333 单位长度。 在其内部左上角顶点有一小球 (无视其体积)，其初速度如图所示且保持运动速率不变，分解到长宽两个方向上的速率之比为 dx:dy=15:17。 小球碰到长方形的边框时会发生反弹，每次反弹的入射角与反射角相等，因此小球会改变方向且保持速率不变（如果小球刚好射向角落，则按入射方向原路返回）。从小球出发到其第一次回到左上角顶点这段时间里，小球运动的路程为多少单位长度？答案四舍五入保留两位小数。<br>![[Pasted image 20260119121851.png]]<br>可以把小球每次反弹都投影到一个镜像世界里面<br>假设lenth=343720,wide=233333<br>![[未命名绘图.drawio.png]]<br>我们可以观察到原点在镜像世界中的投影点满足x为2 <em> lenth的整数倍数,y为2 </em> wide的整数倍数。小球每时每刻沿直线运动在x和y轴上的分量都满足15:17。<br>枚举t从1到正无穷,使得小球在t时刻的x和y运动分量满足到达原点所要求的条件。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx=<span class="number">15</span>,dy=<span class="number">17</span>,wide=<span class="number">2</span>*<span class="number">233333</span>,lenth=<span class="number">2</span>*<span class="number">343720</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t*dx%lenth==<span class="number">0</span>&amp;&amp;t*dy%wide==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line">            cout&lt;&lt;fixed&lt;&lt;<span class="built_in">hypot</span>(t*dx,t*dy);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神奇闹钟</title>
      <link href="/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/8.%E7%A5%9E%E5%A5%87%E9%97%B9%E9%92%9F/"/>
      <url>/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/8.%E7%A5%9E%E5%A5%87%E9%97%B9%E9%92%9F/</url>
      
        <content type="html"><![CDATA[<p>小蓝发现了一个神奇的闹钟, 从纪元时间（1970 年 1月 1日 00: 00: 00）开始, 每经过 x 分钟, 这个闹钟便会触发一次闹铃 (纪元时间也会响铃). 这引起了小蓝的兴趣, 他想要好好研究下这个闹钟.<br>对于给出的时间一个格式为 yyyy-MM-dd HH:mm:ss 的时间, 小蓝想要知道在这个时间点之前(包含这个时间点)最近的一次闹铃是什么时间?<br>注意,你不必考虑时区问题。<br>输入格式<br>输入的第一行包含一个整数 T , 表示每次输入包含 T 组数据.<br>接下来依次描述 T 组数据.<br>每组数据一行。包含一个时间（格式为 yyyy-MM-dd HH:mm:ss）和一个整数 x ，其中 x表示闹铃时间间隔（单位为分钟）.<br>输出格式<br>输出 T 行. 每行包含一个时间（格式为 yyyy-MM-dd HH:mm:ss），依次表示每组数据的答案。</p><p>首先把从1970年到输入时间之间的秒数long long res算出来,再计算出可以触发闹铃的次数n= (res / (x <em> 60)) ,从而计算出从1970年开始到最后一次闹铃之间的秒数res= (res / (x</em>60)) <em> x </em> 60,再把这个秒数转化为题目要求的时间格式<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gettimestamp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d,<span class="type">int</span> e,<span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> IsLeapYear=((a%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; a%<span class="number">100</span>!=<span class="number">0</span>) || (a%<span class="number">400</span>==<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> MonthDay[<span class="number">12</span>]=&#123;<span class="number">31</span>,<span class="number">28</span>+IsLeapYear,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> commonyear=<span class="number">365</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> leapyear=<span class="number">366</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1970</span>;i&lt;a;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; i%<span class="number">100</span>!=<span class="number">0</span>) || (i%<span class="number">400</span>==<span class="number">0</span>))</span><br><span class="line">        res+=leapyear;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        res+=commonyear;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;b;j++)</span><br><span class="line">    res+=MonthDay[j<span class="number">-1</span>]*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;c;k++)</span><br><span class="line">    res+=<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=d;l++)</span><br><span class="line">    res+=<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">1</span>;m&lt;=e;m++)</span><br><span class="line">    res+=<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">1</span>;n&lt;=f;n++)</span><br><span class="line">    res+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintTime</span><span class="params">(<span class="type">long</span> <span class="type">long</span> res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> year=<span class="number">1970</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> secyear=(<span class="number">365</span>+((year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span>) || (year%<span class="number">400</span>==<span class="number">0</span>)))*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;=secyear)</span><br><span class="line">        &#123;</span><br><span class="line">            year++;</span><br><span class="line">            res-=secyear;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> MonthDay[<span class="number">12</span>]=&#123;<span class="number">31</span>,<span class="number">28</span>+((year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span>) || (year%<span class="number">400</span>==<span class="number">0</span>)),<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">    <span class="type">int</span> month=<span class="number">1</span>,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;=MonthDay[i]*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res-=MonthDay[i]*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            month+=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> day=<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;=<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res-=<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            day+=j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> hour = res/<span class="number">3600</span>; res%= <span class="number">3600</span>;</span><br><span class="line">    <span class="type">int</span> minute = res/<span class="number">60</span>; res%= <span class="number">60</span>;</span><br><span class="line">    <span class="type">int</span> second = res;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%04d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, year, month, day, hour, minute, second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=T;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c,d,e,f,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d-%d-%d %d:%d:%d %d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,&amp;x);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res=<span class="built_in">gettimestamp</span>(a,b,c,d,e,f);</span><br><span class="line">        res= (res / (x*<span class="number">60</span>)) * x * <span class="number">60</span>;</span><br><span class="line">        <span class="built_in">PrintTime</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特殊日期</title>
      <link href="/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/6.%E7%89%B9%E6%AE%8A%E6%97%A5%E6%9C%9F/"/>
      <url>/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/6.%E7%89%B9%E6%AE%8A%E6%97%A5%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>记一个日期为 yy 年 mm 月 dd 日。统计从 2000 年 1 月 1 日（含）到 2000000 年 1 月 1 日（含），有多少个日期满足年份 yy 是月份 mm 的倍数，同时也是 dd 的倍数。<br>当年份是 4 的倍数而不是 100 的倍数或者年份是 400 的倍数时，这一年是闰年，其他的年份都不是闰年。<br>遍历每一年的每一个月的每一天。二月份天数最为特殊,闰年29，平年28<br>我们可以先创建一个数组int  MonthDay[12]={31,28,31,30,31,30,31,31,30,31,30,31}<br>在遍历年的循环中设置一个flag=((i%4 == 0 &amp;&amp; i%100!=0) || (i%400 == 0))<br>更新MonthDay[1]=28+flag<br>这样就解决二月份天数问题<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> MonthDay[<span class="number">12</span>]=&#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2000</span>;i&lt;=<span class="number">1999999</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> IsLeapYear=((i%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; i%<span class="number">100</span>!=<span class="number">0</span>) || (i%<span class="number">400</span>==<span class="number">0</span>));</span><br><span class="line">        MonthDay[<span class="number">1</span>]=<span class="number">28</span>+IsLeapYear;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">12</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=MonthDay[j<span class="number">-1</span>];k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i%j==<span class="number">0</span>&amp;&amp;i%k==<span class="number">0</span>)</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期统计</title>
      <link href="/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/7.%E6%97%A5%E6%9C%9F%E7%BB%9F%E8%AE%A1/"/>
      <url>/2026/01/27/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/7.%E6%97%A5%E6%9C%9F%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>小蓝现在有一个长度为100的数组，数组中的每个元素的值都在0 到9 的范围之内。数组中的元素从左至右如下所示<br>5 6 8 6 9 1 6 1 2 4 9 1 9 8 2 3 6 4 7 7 5 9 5 0 3 8 7 5 8 1 5 8 6 1 8 3 0 3 7 9 2 7 0 5 8 8 5 7 0 9 9 1 9 4 4 6 8 6 3 3 8 5 1 6 3 4 6 7 0 7 8 2 7 6 8 9 5 6 5 6 1 4 0 1 0 0 9 4 8 0 9 1 2 8 5 0 2 5 3 3<br>现在他想要从这个数组中寻找一些满足以下条件的子序列：<br>子序列的长度为8；<br>这个子序列可以按照下标顺序组成一个yyyymmdd 格式的日期，并且要求这个日期是2023 年中的某一天的日期，例如20230902，20231223。yyyy 表示年份，mm 表示月份，dd 表示天数，当月份或者天数的长度只有一位时需要一个前导零补充。<br>请你帮小蓝计算下按上述条件一共能找到多少个不同的2023 年的日期。<br>对于相同的日期你只需要统计一次即可。</p><p>枚举2023年的每一天进行子序列的匹配<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">daysmatch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;numbers,vector&lt;<span class="type">int</span>&gt;&amp;match)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">99</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(numbers[i]==match[idx])</span><br><span class="line">      idx++;</span><br><span class="line">      <span class="keyword">if</span>(idx==match.<span class="built_in">size</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> vector &lt;<span class="type">int</span>&gt; numbers=&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>,</span><br><span class="line"> <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>,</span><br><span class="line"> <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"> <span class="number">8</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> MonthDay[<span class="number">12</span>]=&#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> month=<span class="number">1</span>;month&lt;=<span class="number">12</span>;month++)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> day=<span class="number">1</span>;day&lt;=MonthDay[month<span class="number">-1</span>];day++)</span><br><span class="line">   &#123;</span><br><span class="line">      vector &lt;<span class="type">int</span>&gt; match=&#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,month/<span class="number">10</span>,month%<span class="number">10</span>,day/<span class="number">10</span>,day%<span class="number">10</span>&#125;;</span><br><span class="line">      cnt+=<span class="built_in">daysmatch</span>(numbers,match);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> cout&lt;&lt;cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>差分</title>
      <link href="/2026/02/07/19.%E5%B7%AE%E5%88%86/"/>
      <url>/2026/02/07/19.%E5%B7%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="快速处理区间加减-前缀和的逆运算"><a href="#快速处理区间加减-前缀和的逆运算" class="headerlink" title="快速处理区间加减(前缀和的逆运算)"></a>快速处理区间加减(前缀和的逆运算)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line"> d[i]=a[i];</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> d[i]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 1 1 1                                      1 1 1 1<br>前缀和得到                               差分得到<br>1 2 3 4                                      1 0 0 0<br>差分得到                                   前缀和得到<br>1 1 1 1 恢复为原数组                 1  1 1 1  恢复为原数组</p><h2 id="和前缀和互为逆运算："><a href="#和前缀和互为逆运算：" class="headerlink" title="和前缀和互为逆运算："></a>和前缀和互为逆运算：</h2><p>前缀和数组做差分:</p><ul><li><script type="math/tex; mode=display">s_i = a_0 + a_1 + \dots + a_{i-1} + a_i</script></li><li>($i$ 位置的前缀和是 $0$ 到 $i$ 的总和)</li><li><script type="math/tex; mode=display">s_{i-1} = a_0 + a_1 + \dots + a_{i-1}</script></li><li>($i-1$ 位置的前缀和是 $0$ 到 $i-1$ 的总和)</li><li><strong>相减得出</strong>：<script type="math/tex; mode=display">s_i - s_{i-1} = a_i</script></li><li>这意味着：前缀和数组的<strong>差分</strong>（相邻项相减）就是原数组的元素。</li></ul><p>差分数组计算前缀和:</p><ul><li><script type="math/tex; mode=display">d_i = a_i - a_{i-1}</script></li><li><script type="math/tex; mode=display">d_{i-1} = a_{i-1} - a_{i-2}</script></li><li>… （中间省略）</li><li><script type="math/tex; mode=display">d_1 = a_1 - a_0</script></li><li><script type="math/tex; mode=display">d_0 = a_0</script></li><li><strong>左边相加</strong>：<br><script type="math/tex">d_0 + d_1 + \dots + d_i</script>这实际上就是在对差分数组 $d$ 求前缀和。</li></ul><h2 id="a-l-r-k-Longleftrightarrow-d-l-k-quad-d-r-1-k"><a href="#a-l-r-k-Longleftrightarrow-d-l-k-quad-d-r-1-k" class="headerlink" title="$a[l, r] + k \Longleftrightarrow d[l] + k, \quad d[r+1] - k$"></a>$a[l, r] + k \Longleftrightarrow d[l] + k, \quad d[r+1] - k$</h2><p>如果你想给原数组 $a$ 的区间 $[l, r]$ 内的所有数字都加上 $k$，你只需要在差分数组 $d$ 的左边界 $l$ 处加上 $k$，并在右边界的下一个位置 $r+1$ 处减去 $k$。<br>![[Pasted image 20260207195742.png]]<br>![[Pasted image 20260207195810.png]]</p><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><p>先对每一列差分,再对每一行差分<br>![[Pasted image 20260207200659.png]]</p><h2 id="异或差分"><a href="#异或差分" class="headerlink" title="异或差分"></a>异或差分</h2><p>![[Pasted image 20260207201043.png]]</p><h3 id="第一步：构造异或差分数组"><a href="#第一步：构造异或差分数组" class="headerlink" title="第一步：构造异或差分数组"></a>第一步：构造异或差分数组</h3><p>将原数组转化为一个“异或差分”序列。</p><ul><li><strong>计算规则：</strong> 差分数组 $d[i] = a[i] \oplus a[i-1]$（规定 $a[0] = 0$）。</li><li><strong>图片示例：</strong> 原数组 <code>[1, 2, 3, 4, 5, 6]</code> 经过“差分”后变为 <code>[1, 3, 1, 7, 1, 3]</code>。<ul><li>$1 \oplus 0 = 1$</li><li>$2 \oplus 1 = 3$</li><li>$3 \oplus 2 = 1$</li><li>以此类推。<h3 id="第二步：执行区间异或操作"><a href="#第二步：执行区间异或操作" class="headerlink" title="第二步：执行区间异或操作"></a>第二步：执行区间异或操作</h3>假设要在区间 $[l, r]$ 上统一异或一个值 $k$。在差分数组上，这只需要修改两个点。</li></ul></li><li><strong>操作公式：</strong><ol><li>$d[l] = d[l] \oplus k$</li><li>$d[r+1] = d[r+1] \oplus k$</li></ol></li><li><strong>图片示例：</strong> 对区间 $[2, 5]$ 执行 <code>^ 2</code>（异或 2）。<ul><li>修改左端点（索引 2）：原来的 $3 \oplus 2 = 1$。</li><li>修改右端点外侧（索引 6）：原来的 $3 \oplus 2 = 1$。</li><li>修改后的差分数组变为：<code>[1, 1, 1, 7, 1, 1]</code>。<h3 id="第三步：还原结果（前缀异或和）"><a href="#第三步：还原结果（前缀异或和）" class="headerlink" title="第三步：还原结果（前缀异或和）"></a>第三步：还原结果（前缀异或和）</h3>通过对修改后的差分数组求<strong>前缀异或和</strong>，得到最终的修改结果。</li></ul></li><li><strong>计算公式：</strong> $a’[i] = d[1] \oplus d[2] \oplus \dots \oplus d[i]$。</li><li><strong>图片示例：</strong> 对 <code>[1, 1, 1, 7, 1, 1]</code> 求前缀异或和。<ol><li>第 1 位：$1$</li><li>第 2 位：$1 \oplus 1 = 0$</li><li>第 3 位：$0 \oplus 1 = 1$</li><li>第 4 位：$1 \oplus 7 = 6$</li><li>第 5 位：$6 \oplus 1 = 7$</li><li>第 6 位：$7 \oplus 1 = 6$</li></ol></li><li><strong>最终数组：</strong> <code>[1, 0, 1, 6, 7, 6]</code>。<br>对于区间 $[l, r]$ 进行异或 $k$ 的操作，其差分逻辑为：</li></ul><script type="math/tex; mode=display">d[l] = d[l] \oplus k</script><script type="math/tex; mode=display">d[r+1] = d[r+1] \oplus k</script><h2 id="利用多重差分来解决多项式形式的区间修改"><a href="#利用多重差分来解决多项式形式的区间修改" class="headerlink" title="利用多重差分来解决多项式形式的区间修改"></a>利用<strong>多重差分</strong>来解决<strong>多项式形式的区间修改</strong></h2><p>![[Pasted image 20260207215111.png]]</p><h3 id="1-核心概念：差分与导数的关系"><a href="#1-核心概念：差分与导数的关系" class="headerlink" title="1. 核心概念：差分与导数的关系"></a>1. 核心概念：差分与导数的关系</h3><p>在离散数学中，<strong>差分（Difference）</strong>之于数列，就相当于<strong>导数（Derivative）</strong>之于连续函数。</p><ul><li>常数的导数是 0。</li><li>$x$（一次函数）的导数是常数。</li><li>$x^2$（二次函数）的导数是一次函数。<br><strong>差分也是同理：</strong><br>每一次差分操作，都会把多项式的最高次幂降低 1 次。<h3 id="2-图片公式逐行详解"><a href="#2-图片公式逐行详解" class="headerlink" title="2. 图片公式逐行详解"></a>2. 图片公式逐行详解</h3>图片中列举了不同复杂度的修改（$add_x$），以及它们对应的处理方式。<h4 id="第一行：-add-x-a-（常数修改）"><a href="#第一行：-add-x-a-（常数修改）" class="headerlink" title="第一行：$add_x = a$ （常数修改）"></a><strong>第一行：$add_x = a$ （常数修改）</strong></h4></li><li><strong>含义</strong>：这是最基础的区间修改。比如“给区间 $[L, R]$ 的每个数都加上常数 $a$”。</li><li><strong>多项式次数</strong>：$0$ 次（因为 $a = a \cdot x^0$）。</li><li><strong>所需差分阶数</strong>：<strong>一阶差分</strong>。</li><li><strong>原理</strong>：<br>  常数序列（如 $3, 3, 3, 3$）做一次差分后，中间全是 $0$（除了边界）。<ul><li>原数：$0, 0, 3, 3, 3, 3, 0$</li><li>一阶差分：$0, 0, 3, 0, 0, 0, -3$</li><li><strong>结论</strong>：只需要修改两个点（$L$ 和 $R+1$），就能代表整个区间的修改。<h4 id="第二行：-add-x-a-bx-（线性-等差数列修改）"><a href="#第二行：-add-x-a-bx-（线性-等差数列修改）" class="headerlink" title="第二行：$add_x = a + bx$ （线性/等差数列修改）"></a><strong>第二行：$add_x = a + bx$ （线性/等差数列修改）</strong></h4></li></ul></li><li><strong>含义</strong>：给区间加上一个等差数列。比如“给第 $x$ 个数加上 $2x+1$”。</li><li><strong>多项式次数</strong>：$1$ 次。</li><li><strong>所需差分阶数</strong>：<strong>二阶差分</strong>。</li><li><strong>原理</strong>：<ul><li>原增量序列（线性）：$1, 3, 5, 7, 9$ （这是一个一次函数）</li><li>一阶差分：$1, 2, 2, 2, 2$ （变成了常数序列，除了开头）</li><li>二阶差分：$1, 1, 0, 0, 0$ （中间变成了 0）</li><li><strong>结论</strong>：对一个线性增长的区间修改，维护二阶差分数组，只需要在边界处进行 $O(1)$ 的修改。<h4 id="第三行：-add-x-a-bx-cx-2-（二次函数修改）"><a href="#第三行：-add-x-a-bx-cx-2-（二次函数修改）" class="headerlink" title="第三行：$add_x = a + bx + cx^2$ （二次函数修改）"></a><strong>第三行：$add_x = a + bx + cx^2$ （二次函数修改）</strong></h4></li></ul></li><li><strong>含义</strong>：给区间加上一个平方级别的增长量。比如“物理中的匀加速运动位移”。</li><li><strong>多项式次数</strong>：$2$ 次。</li><li><strong>所需差分阶数</strong>：<strong>三阶差分</strong>。</li><li><p><strong>原理</strong>：</p><ul><li>$x^2$ 做差分变成 $(x+1)^2 - x^2 = 2x+1$（降级为一次函数）。</li><li>再做差分变成常数。</li><li>再做差分变成 0。</li><li><strong>结论</strong>：只要是 $n$ 次多项式，做 $n+1$ 次差分后，区间内部的值就会变成 0，只剩下边界有值。<h3 id="3-为什么是“多项式累加-Longrightarrow-多重差分”？"><a href="#3-为什么是“多项式累加-Longrightarrow-多重差分”？" class="headerlink" title="3. 为什么是“多项式累加 $\Longrightarrow$ 多重差分”？"></a>3. 为什么是“多项式累加 $\Longrightarrow$ 多重差分”？</h3>这张图推导出的通用法则是：</li></ul></li></ul><ol><li><strong>降维打击</strong>：利用差分性质，把复杂的曲线（高次多项式）通过多次差分“打平”成 0。</li><li><strong>操作</strong>：<ul><li>如果你要加一个 <strong>$k$ 次多项式</strong>。</li><li>你就建立一个 <strong>$k+1$ 阶差分数组</strong>。</li><li>你只需要在这个高阶差分数组的 <strong>$L$（起点）</strong> 和 <strong>$R$（终点）</strong> 附近修改少数几个值。</li></ul></li><li><strong>还原</strong>：<ul><li>当询问最终结果时，对这个 $k+1$ 阶差分数组做 <strong>$k+1$ 次前缀和（Prefix Sum）</strong>，就能还原出原始数组的增量。</li></ul></li></ol><h2 id="差分的正负性反应了原数组的增减性"><a href="#差分的正负性反应了原数组的增减性" class="headerlink" title="差分的正负性反应了原数组的增减性"></a>差分的正负性反应了原数组的增减性</h2><p>![[Pasted image 20260207221544.png]]</p><h3 id="1-核心逻辑：从“面”到“点”的降维"><a href="#1-核心逻辑：从“面”到“点”的降维" class="headerlink" title="1. 核心逻辑：从“面”到“点”的降维"></a>1. 核心逻辑：从“面”到“点”的降维</h3><ul><li><strong>左边（原数组视角）</strong>：<ul><li><strong>操作</strong>：<code>任选 [L, R]</code>，让区间内所有元素加 1 或减 1。</li><li><strong>难点</strong>：每次操作涉及很多个数，状态难以穷举。</li><li><strong>目标</strong>：想让原数组变成<strong>递增</strong>、<strong>递减</strong>或者<strong>所有数相等</strong>。</li></ul></li><li><strong>右边（差分数组视角）</strong>：<ul><li><strong>操作</strong>：由于差分的性质（$D[L]+v, D[R+1]-v$），原数组的一次区间修改，等价于在差分数组中<strong>任选两个位置</strong>，一个加 1，一个减 1。<ul><li>_特殊情况_：如果只选一个位置修改（比如只改 $L$ 处），其实是因为另一个位置选在了 $N+1$（越界无效位置），图中的 <code>X | 1 2 3 4 | X</code> 就在暗示这种边界处理。</li></ul></li><li><strong>优势</strong>：操作从“修改一排数”变成了“修改两个数”，复杂度大大降低。</li><li><strong>目标</strong>：<ul><li>原数组<strong>递增</strong> $\Longleftrightarrow$ 差分数组每一项（除第一项外）都 $\ge 0$。</li><li>原数组<strong>递减</strong> $\Longleftrightarrow$ 差分数组每一项（除第一项外）都 $\le 0$。</li><li>原数组<strong>相等</strong> $\Longleftrightarrow$ 差分数组每一项（除第一项外）都 $= 0$。<h3 id="2-经典案例解析：IncDec-Sequence"><a href="#2-经典案例解析：IncDec-Sequence" class="headerlink" title="2. 经典案例解析：IncDec Sequence"></a>2. 经典案例解析：IncDec Sequence</h3>这张图其实对应了一道非常经典的算法题（NOIp 2011 提高组《IncDec Sequence》）。<br><strong>问题描述</strong><br>给定一个数组，每次可以选择一个区间 $[L, R]$ 进行 $+1$ 或 $-1$ 操作。问最少操作多少次，能让数组中<strong>所有元素都相等</strong>？<br><strong>结合这张图的解法</strong>：</li></ul></li></ul></li></ul><ol><li><strong>转化目标</strong>：<br> 让“原数组所有元素相等”，等价于让“差分数组 $D[2], D[3] \dots D[n]$ 全部变为 0”。（注意 $D[1]$ 不需要为 0，因为 $D[1]$ 决定了最终相等的那个数值是多少）。</li><li><strong>分析现状</strong>：<br> 计算出初始的差分数组后，你会发现 $D[2 \dots n]$ 中有一些<strong>正数</strong>（需要减），有一些<strong>负数</strong>（需要加）。</li><li><strong>匹配操作（图中的“任选两个位置”）</strong>：<ul><li><strong>贪心策略 1</strong>：优先在 $D[2 \dots n]$ 内部找一正一负进行配对。比如 $D[i] &gt; 0, D[j] &lt; 0$，我们就对区间 $[i, j-1]$ 操作。这样能一次性解决两个数的偏差（“一个加，一个减”），效率最高。</li><li><strong>贪心策略 2</strong>：如果正负无法配对（比如只剩下正数了），那就只能和边界（$D[1]$ 或 $D[n+1]$）配对。这对应图中“任选一个位置，增加/减少”。</li></ul></li><li><strong>结论</strong>：<br> 通过把复杂的区间问题转化为差分数组上的<strong>正负数抵消</strong>游戏，我们可以瞬间得出最少操作次数公式：$\max(\text{正数和}, |\text{负数和}|)$。<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3>这张图想表达的是差分技术的<strong>最高境界</strong>：<br>不仅仅是用它来快速修改数据（如前两张图所述），而是用它来<strong>重构问题的定义</strong>。</li></ol><ul><li><strong>看到“区间加减”</strong> $\rightarrow$ 转化为 <strong>“差分数组的两点修改”</strong>。</li><li><strong>看到“单调性/相等”目标</strong> $\rightarrow$ 转化为 <strong>“差分数组的正负/零”目标</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 差分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL库</title>
      <link href="/2026/02/07/C++STL%E5%BA%93/"/>
      <url>/2026/02/07/C++STL%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="向量-vector"><a href="#向量-vector" class="headerlink" title="向量 vector"></a>向量 <a href="https://zh.cppreference.com/w/cpp/container/vector">vector</a></h2><p><strong><code>#include &lt;vector&gt;</code></strong><br>连续的顺序的储存结构（和数组一样的类别），但是有长度可变的特性。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p><strong><code>vector&lt;类型&gt; arr(长度, [初值])</code></strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>,<span class="number">0</span>)</span></span>; <span class="comment">//构造初始长为100的int一维数组,初始值全为0</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">arr</span>(<span class="number">100</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//构造行数为100,列数不定的二维数组</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">arr</span>(<span class="number">100</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">666</span>,<span class="number">-1</span>)); <span class="comment">//构造行数为100,列数为666的二维数组,初始值为-1</span></span><br></pre></td></tr></table></figure></p><h4 id="尾接-amp-尾删"><a href="#尾接-amp-尾删" class="headerlink" title="尾接 &amp; 尾删"></a>尾接 &amp; 尾删</h4><ul><li><strong><code>.push_back(元素)</code></strong>：在 vector 尾接一个元素</li><li><strong><code>.pop_back()</code></strong>：删除 vector 尾部的一个元素<h4 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h4><strong><code>.size()</code></strong><br>获取当前 vector 的长度<h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><strong><code>.clear()</code></strong><br>清空 vector<h4 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h4><strong><code>.empty()</code></strong><br>如果是空返回 <code>true</code> 反之返回 <code>false</code>.<h4 id="改变长度"><a href="#改变长度" class="headerlink" title="改变长度"></a>改变长度</h4><strong><code>.resize(新长度, [默认值])</code></strong><br>修改 vector 的长度</li><li>如果是缩短，则删除多余的值</li><li>如果是扩大，且指定了默认值，则新元素均为默认值（旧元素不变）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">arr</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:arr)</span><br><span class="line">    cout&lt;&lt;x;  <span class="comment">//111</span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    arr.<span class="built_in">resize</span>(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:arr)</span><br><span class="line">    cout&lt;&lt;x; <span class="comment">//1110</span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    arr.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:arr)</span><br><span class="line">    cout&lt;&lt;x; <span class="comment">//11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 <a href="https://zh.cppreference.com/w/cpp/container/stack">stack</a></h2><p>通过二次封装双端队列 (deque) 容器，实现先进后出的栈数据结构。</p><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>构造</td><td><code>stack&lt;类型&gt; stk</code></td><td><code>stack&lt;int&gt; stk;</code></td></tr><tr><td>进栈</td><td><code>.push(元素)</code></td><td><code>stk.push(1);</code></td></tr><tr><td>出栈</td><td><code>.pop()</code></td><td><code>stk.pop();</code></td></tr><tr><td>取栈顶</td><td><code>.top()</code></td><td><code>int a = stk.top();</code></td></tr><tr><td>查看大小 / 清空 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><h2 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列 queue"></a>队列 <a href="https://zh.cppreference.com/w/cpp/container/queue">queue</a></h2><p><strong><code>#include &lt;queue&gt;</code></strong><br>通过二次封装双端队列 (deque) 容器，实现先进先出的队列数据结构。</p><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>构造</td><td><code>queue&lt;类型&gt; que</code></td><td><code>queue&lt;int&gt; que;</code></td></tr><tr><td>进队</td><td><code>.push(元素)</code></td><td><code>que.push(1);</code></td></tr><tr><td>出队</td><td><code>.pop()</code></td><td><code>que.pop();</code></td></tr><tr><td>取队首</td><td><code>.front()</code></td><td><code>int a = que.front();</code></td></tr><tr><td>取队尾</td><td><code>.back()</code></td><td><code>int a = que.back();</code></td></tr><tr><td>查看大小 / 清空 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><h2 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列 priority_queue"></a>优先队列 <a href="https://zh.cppreference.com/w/cpp/container/priority_queue">priority_queue</a></h2><p><strong><code>#include &lt;queue&gt;</code></strong><br>提供常数时间的最大元素查找，对数时间的插入与提取，底层原理是二叉堆。</p><h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h4><p><strong><code>priority_queue&lt;类型, 容器, 比较器&gt; pque</code></strong></p><ul><li>类型：要储存的数据类型</li><li>容器：储存数据的底层容器，默认为 <code>vector&lt;类型&gt;</code>，竞赛中保持默认即可</li><li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pque1;                            <span class="comment">// 储存int的大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pque2; <span class="comment">// 储存int的小顶堆</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>进堆</td><td><code>.push(元素)</code></td><td><code>que.push(1);</code></td></tr><tr><td>出堆</td><td><code>.pop()</code></td><td><code>que.pop();</code></td></tr><tr><td>取堆顶</td><td><code>.top()</code></td><td><code>int a = que.top();</code></td></tr><tr><td>查看大小 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt;pque;</span><br><span class="line"> pque.<span class="built_in">push</span>(<span class="number">6</span>);</span><br><span class="line"> pque.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line"> pque.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"> cout&lt;&lt;pque.<span class="built_in">top</span>()&lt;&lt;endl; <span class="comment">//6</span></span><br><span class="line"> pque.<span class="built_in">pop</span>();</span><br><span class="line"> cout&lt;&lt;pque.<span class="built_in">top</span>();  <span class="comment">//5</span></span><br></pre></td></tr></table></figure><h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 <a href="https://zh.cppreference.com/w/cpp/container/set">set</a></h2><p><strong><code>#include &lt;set&gt;</code></strong><br>提供对数时间的插入、删除、查找的集合数据结构。底层原理是红黑树。</p><div class="table-container"><table><thead><tr><th>集合三要素</th><th>解释</th><th>set</th><th>multiset</th><th>unordered_set</th></tr></thead><tbody><tr><td>确定性</td><td>一个元素要么在集合中，要么不在</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>互异性</td><td>一个元素仅可以在集合中出现一次</td><td>✔</td><td>❌（任意次）</td><td>✔</td></tr><tr><td>无序性</td><td>集合中的元素是没有顺序的</td><td>❌（从小到大）</td><td>❌（从小到大）</td><td>✔</td></tr></tbody></table></div><h3 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h4><p><strong><code>set&lt;类型, 比较器&gt; st</code></strong></p><ul><li>类型：要储存的数据类型</li><li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; st1;               <span class="comment">// 储存int的集合（从小到大）</span></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; st2; <span class="comment">// 储存int的集合（从大到小）</span></span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4>可使用迭代器进行遍历：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure>基于范围的循环（C++ 11）：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ele : st)</span><br><span class="line">    cout &lt;&lt; ele &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4></li></ul><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>插入元素</td><td><code>.insert(元素)</code></td><td><code>st.insert(1);</code></td></tr><tr><td>删除元素</td><td><code>.erase(元素)</code></td><td><code>st.erase(2);</code></td></tr><tr><td>查找元素</td><td><code>.find(元素)</code></td><td><code>auto it = st.find(1);</code></td></tr><tr><td>判断元素是否存在</td><td><code>.count(元素)</code></td><td><code>st.count(3);</code></td></tr><tr><td>查看大小 / 清空 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><p>对于查找元素的find</p><ul><li><strong>找到了</strong> → 返回指向该元素的 <strong>迭代器</strong></li><li><strong>没找到</strong> → 返回 <code>st.end()</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:s)</span><br><span class="line">cout&lt;&lt;x;</span><br><span class="line"><span class="keyword">auto</span> it=s.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">cout&lt;&lt;s.<span class="built_in">count</span>(<span class="number">4</span>)&lt;&lt;s.<span class="built_in">count</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>set 的迭代器不能像 vector 一样相减得到下标。<strong>下面是错误用法：</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = st.<span class="built_in">find</span>(<span class="number">2</span>);      <span class="comment">// 正确，返回2所在位置的迭代器。</span></span><br><span class="line"><span class="type">int</span> idx = it - st.<span class="built_in">begin</span>(); <span class="comment">// 错误！不可相减得到下标。</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 map"></a>映射 <a href="https://zh.cppreference.com/w/cpp/container/map">map</a></h2><p><strong><code>include &lt;map&gt;</code></strong><br>提供对数时间的有序键值对结构。底层原理是红黑树。</p><div class="table-container"><table><thead><tr><th>性质</th><th>解释</th><th>map</th><th>multimap</th><th>unordered_map</th></tr></thead><tbody><tr><td>互异性</td><td>一个键仅可以在映射中出现一次</td><td>✔</td><td>❌（任意次）</td><td>✔</td></tr><tr><td>无序性</td><td>键是没有顺序的</td><td>❌（从小到大）</td><td>❌（从小到大）</td><td>✔</td></tr></tbody></table></div><h3 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="构造-3"><a href="#构造-3" class="headerlink" title="构造"></a>构造</h4><p><strong><code>map&lt;键类型, 值类型, 比较器&gt; mp</code></strong></p><ul><li>键类型：要储存键的数据类型</li><li>值类型：要储存值的数据类型</li><li>比较器：键比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp1;               <span class="comment">// int-&gt;int 的映射（键从小到大）</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; st2; <span class="comment">// int-&gt;int 的映射（键从大到小）</span></span><br></pre></td></tr></table></figure><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4>可使用迭代器进行遍历：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>基于范围的循环（C++ 11）：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pr : mp)</span><br><span class="line">    cout &lt;&lt; pr.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pr.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>结构化绑定 + 基于范围的循环（C++17）：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[key, val] : mp)</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4></li></ul><div class="table-container"><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>增 / 改 / 查元素</td><td>中括号</td><td><code>mp[1] = 2;</code></td></tr><tr><td>查元素（返回迭代器）</td><td><code>.find(元素)</code></td><td><code>auto it = mp.find(1);</code></td></tr><tr><td>删除元素</td><td><code>.erase(元素)</code></td><td><code>mp.erase(2);</code></td></tr><tr><td>判断元素是否存在</td><td><code>.count(元素)</code></td><td><code>mp.count(3);</code></td></tr><tr><td>查看大小 / 清空 / 判空</td><td>略</td><td>略</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">m[<span class="number">1</span>]=<span class="number">8</span>;</span><br><span class="line">m[<span class="number">7</span>]=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [key,val]:m)</span><br><span class="line">cout&lt;&lt;key&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;val&lt;&lt;endl;</span><br><span class="line">m[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [key,val]:m)</span><br><span class="line">cout&lt;&lt;key&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;val&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>如果使用中括号访问 map 时对应的键不存在，那么会新增这个键，并且值为默认值，因此中括号会影响键的存在性。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">count</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>];                       <span class="comment">// 即使什么都没做，此时mp[&#x27;a&#x27;]=0已经插入了</span></span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">count</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; mp[<span class="string">&#x27;a&#x27;</span>] &lt;&lt; endl;       <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p><h1 id="迭代器简介"><a href="#迭代器简介" class="headerlink" title="迭代器简介"></a>迭代器简介</h1><h2 id="迭代器是什么？"><a href="#迭代器是什么？" class="headerlink" title="迭代器是什么？"></a>迭代器是什么？</h2><p>对于一个 vector，我们可以用下标遍历：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><br>我们同时也可以用迭代器来遍历：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p><ul><li><code>a.begin()</code> 是一个迭代器，指向的是第一个元素</li><li><code>a.end()</code> 是一个迭代器，指向的是最后一个元素<strong>再后面一位</strong></li><li>上述迭代器具有自增运算符，自增则迭代器向下一个元素移动</li><li>迭代器与指针相似，如果对它使用解引用运算符，即 <code>*it</code>，就能取到对应值了</li></ul><h2 id="迭代器用法"><a href="#迭代器用法" class="headerlink" title="迭代器用法"></a>迭代器用法</h2><ul><li><code>.begin()</code>：头迭代器</li><li><code>.end()</code>：尾迭代器</li><li><code>.rbegin()</code>：反向头迭代器</li><li><code>.rend()</code>：反向尾迭代器</li><li>迭代器 <code>+</code> 整型：将迭代器向后移动</li><li>迭代器 <code>-</code> 整型：将迭代器向前移动</li><li>迭代器 <code>++</code>：将迭代器向后移动 1 位</li><li>迭代器 <code>--</code>：将迭代器向前移动 1 位</li><li>迭代器 <code>-</code> 迭代器：两个迭代器的距离</li><li><code>prev(it)</code>：返回 it 的前一个迭代器</li><li><code>next(it)</code>：返回 it 的后一个迭代器</li></ul><h2 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound() / upper_bound()"></a><code>lower_bound()</code> / <code>upper_bound()</code></h2><p>在<strong>已升序排序</strong>的元素中，应用二分查找检索指定元素，返回对应元素迭代器位置。<strong>找不到则返回尾迭代器。</strong></p><ul><li><code>lower_bound()</code>: 寻找大于等于x的第一个元素的位置</li><li><code>upper_bound()</code>: 寻找小于等于x的第一个元素的位置<br>返回的是迭代器，如何转成下标索引呢？减去头迭代器即可。<br><strong>用法示例</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value )</span></span>;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>);</span><br><span class="line"><span class="type">int</span> idx = it - arr.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// idx = 4</span></span><br></pre></td></tr></table></figure><p>我们通常写成一行：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>&#125;;</span><br><span class="line">idx = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">8</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">upper_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">upper_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">8</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K倍区间</title>
      <link href="/2026/02/05/17.K%E5%80%8D%E5%8C%BA%E9%97%B4/"/>
      <url>/2026/02/05/17.K%E5%80%8D%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="k倍区间"><a href="#k倍区间" class="headerlink" title="k倍区间"></a>k倍区间</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个长度为 $N$ 的数列， $A_1, A_2, \cdots A_N$。如果其中一段连续的子序列 $A_i, A_{i+1}, \cdots A_j (i \le j)$ 之和是 $K$ 的倍数，我们就称这个区间 $[i, j]$ 是 K 倍区间。<br>你能求出数列中总共有多少个 $K$ 倍区间吗？</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>第一行包含两个整数 $N$ 和 $K$ $(1 \le N, K \le 10^5)$。<br>以下 $N$ 行每行包含一个整数 $A_i$ $(1 \le A_i \le 10^5)$。</p><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>输出一个整数，代表 K 倍区间的数目。</p><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p><strong>示例</strong><br><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5 2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/8.png" alt="2222"></p><ul><li><strong>前缀和</strong>：计算数组的前缀和 $S$。</li><li><strong>同余定理</strong>：如果区间 $[i, j]$ 的和是 $K$ 的倍数，即 $(S_j - S_{i-1}) \% K == 0$，这意味着 $S_j \% K == S_{i-1} \% K$。</li><li><strong>转化</strong>：只需要计算前缀和模 $K$ 的余数。如果有 $c$ 个前缀和的余数相同（比如都是 1），那么从这 $c$ 个位置中任选 2 个（$C_c^2$），它们之间的区间和就是 $K$ 的倍数。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,K,sum=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">arr</span>(N<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">cnt</span>(K,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    arr[i]=(arr[i<span class="number">-1</span>]+arr[i])%K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:arr)</span><br><span class="line">    cnt[x]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:cnt)</span><br><span class="line">    sum+=(c<span class="number">-1</span>)*c/<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 2. 修改 `16.区间翻转区间异或和.md`</span><br><span class="line">**修改点**：在文件头部的 Front-matter 中添加了 `mathjax: true`。</span><br><span class="line"></span><br><span class="line">```markdown</span><br><span class="line">---</span><br><span class="line">title: 区间翻转区间异或和       </span><br><span class="line">date: 2026-02-05         </span><br><span class="line">categories:</span><br><span class="line">  - 算法学习           </span><br><span class="line">  - 枚举                  </span><br><span class="line">  - 前缀和题目</span><br><span class="line">tags:</span><br><span class="line">  - 算法</span><br><span class="line">  - 编程</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 题目描述</span><br><span class="line">符卡有一个长度为 $n$ 的整数数组 $a$，符卡认为一个区间 $[l, r]$ 是灵异区间当且仅当 $\bigoplus_&#123;i=l&#125;^r a_i = 0$，或者说这个区间内所有数字异或起来刚好等于 $0$。</span><br><span class="line">符卡有特殊的魔法，可以把任意一个灵异区间翻转。具体来说，如果 $[l, r]$ 区间是灵异区间，那么符卡就可以对这个区间使用魔法，整个数组就会变成 $a_1, a_2, \dots, a_&#123;l-1&#125;, a_r, a_&#123;r-1&#125;, \dots, a_l, a_&#123;r+1&#125;, a_&#123;r+2&#125;, \dots, a_n$。</span><br><span class="line">现在符卡可以使用任意次数的魔法，符卡希望最后得到的数组的灵异区间数量能够尽可能多，你能告诉她最后最多有多少个灵异区间吗？</span><br><span class="line"></span><br><span class="line">### 输入格式</span><br><span class="line">第一行一个正整数 $n$，表示数组长度。</span><br><span class="line">第二行 $n$ 个非负整数 $a_1, a_2, \dots, a_n$ 表示整个数组。</span><br><span class="line">### 输出格式</span><br><span class="line">输出一行一个整数，表示符卡使用任意次魔法后灵异区间最多有多少个。</span><br><span class="line">### 输入输出样例</span><br><span class="line">**输入 #1**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3<br>1 1 1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**输出 #1**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**输入 #2**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4<br>3 1 2 3</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**输出 #2**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">对于如何找到灵异区间我们前面说到过,对整个数组求前缀异或,如果一个区间左右两端的数相等那么这段区间异或和为0。现在对于每个灵异区间要对它翻转,我们要考虑翻转过后对整个数组的应该。每个灵异区间的位置有三种可能。第一种:一个灵异完整地包裹在另一个灵异区间里面,第二种:一个灵异区间部分地包裹在另一个灵异区间里面,第三种:一个灵异区间独立存在,不与其他灵异区间相交。</span><br><span class="line">![2222](/7.png)</span><br><span class="line">所以灵异区间翻转不会产生新的灵异区间或者使灵异区间减少,所以只用统计灵异区间的个数,不用考虑翻转</span><br><span class="line">```cpp</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,sum=0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;int&gt;arr(n+1,0);</span><br><span class="line">    unordered_map&lt;int,int&gt;cnt;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">        arr[i]^=arr[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    for(auto &amp;x:arr)</span><br><span class="line">    cnt[x]++;</span><br><span class="line">    for(auto &amp;[_,c]:cnt)</span><br><span class="line">    sum+=c*(c-1)/2;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拔河</title>
      <link href="/2026/02/05/18.%E6%8B%94%E6%B2%B3/"/>
      <url>/2026/02/05/18.%E6%8B%94%E6%B2%B3/</url>
      
        <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>小明是学校里的一名老师，他带的班级共有 $n$ 名同学，第 $i$ 名同学力量值为 $a_i$。在闲暇之余，小明决定在班级里组织一场拔河比赛。<br>为了保证比赛双方实力尽可能相近，需要在这 $n$ 名同学中挑选出两个队伍，队伍内的同学编号连续：${a_{l_1}, a_{l_1+1}, \dots, a_{r_1}}$ 和 ${a_{l_2}, a_{l_2+1}, \dots, a_{r_2}}$，其中 $l_1 \le r_1 &lt; l_2 \le r_2$。<br>两个队伍的人数不必相同，但是需要让队伍内的同学们的力量值之和尽可能相近。请计算出力量值之和差距最小的挑选队伍的方式。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共两行。<br>第一行为一个正整数 $n$。<br>第二行为 $n$ 个正整数 $a_i$。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共一行，一个非负整数，表示两个队伍力量值之和的最小差距。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">10 9 8 12 14</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h4><p>其中一种最优选择方式：<br>队伍 1：${a_1, a_2, a_3}$，队伍 2：${a_4, a_5}$，力量值和分别为 $10+9+8=27$，$12+14=26$，差距为 $|27-26|=1$。</p><p><img src="/9.png" alt="2222"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,ans=<span class="number">9999999</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">arr</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    arr[i]+=arr[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r1=n<span class="number">-1</span>;r1&gt;=<span class="number">1</span>;r1--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=r1<span class="number">+1</span>;i&lt;=n;i++)</span><br><span class="line">        s.<span class="built_in">insert</span>(arr[i]-arr[r1]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l1=<span class="number">1</span>;l1&lt;=r1;l1++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left_sum=arr[r1]-arr[l1<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">// 3. 在 Set 里找最接近 left_sum 的值</span></span><br><span class="line">            <span class="comment">// lower_bound 找到第一个 &gt;= left_sum 的位置</span></span><br><span class="line">            <span class="keyword">auto</span> it = s.<span class="built_in">lower_bound</span>(left_sum);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 情况 A: 找到了 &gt;= left_sum 的值，算一下差值</span></span><br><span class="line">            <span class="keyword">if</span> (it != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(*it - left_sum));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 情况 B: 它前面的那个值（即 &lt; left_sum 的最大值），也要算一下</span></span><br><span class="line">            <span class="comment">// 因为最接近的值可能是比它大的，也可能是比它小的</span></span><br><span class="line">            <span class="keyword">if</span> (it != s.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> prev_it = <span class="built_in">prev</span>(it); <span class="comment">// 获取迭代器的前一个位置</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(*prev_it - left_sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间翻转区间异或和</title>
      <link href="/2026/02/05/16.%E5%8C%BA%E9%97%B4%E7%BF%BB%E8%BD%AC%E5%8C%BA%E9%97%B4%E5%BC%82%E6%88%96%E5%92%8C/"/>
      <url>/2026/02/05/16.%E5%8C%BA%E9%97%B4%E7%BF%BB%E8%BD%AC%E5%8C%BA%E9%97%B4%E5%BC%82%E6%88%96%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>符卡有一个长度为 $n$ 的整数数组 $a$，符卡认为一个区间 $[l, r]$ 是灵异区间当且仅当 $\bigoplus_{i=l}^r a_i = 0$，或者说这个区间内所有数字异或起来刚好等于 $0$。<br>符卡有特殊的魔法，可以把任意一个灵异区间翻转。具体来说，如果 $[l, r]$ 区间是灵异区间，那么符卡就可以对这个区间使用魔法，整个数组就会变成 $a_1, a_2, \dots, a_{l-1}, a_r, a_{r-1}, \dots, a_l, a_{r+1}, a_{r+2}, \dots, a_n$。<br>现在符卡可以使用任意次数的魔法，符卡希望最后得到的数组的灵异区间数量能够尽可能多，你能告诉她最后最多有多少个灵异区间吗？</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个正整数 $n$，表示数组长度。<br>第二行 $n$ 个非负整数 $a_1, a_2, \dots, a_n$ 表示整个数组。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行一个整数，表示符卡使用任意次魔法后灵异区间最多有多少个。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><p><strong>输入 #1</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure><br><strong>输出 #1</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><br><strong>输入 #2</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3 1 2 3</span><br></pre></td></tr></table></figure><br><strong>输出 #2</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p><p>对于如何找到灵异区间我们前面说到过,对整个数组求前缀异或,如果一个区间左右两端的数相等那么这段区间异或和为0。现在对于每个灵异区间要对它翻转,我们要考虑翻转过后对整个数组的应该。每个灵异区间的位置有三种可能。第一种:一个灵异完整地包裹在另一个灵异区间里面,第二种:一个灵异区间部分地包裹在另一个灵异区间里面,第三种:一个灵异区间独立存在,不与其他灵异区间相交。<br><img src="/7.png" alt="2222"><br>所以灵异区间翻转不会产生新的灵异区间或者使灵异区间减少,所以只用统计灵异区间的个数,不用考虑翻转<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,sum=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">arr</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">        arr[i]^=arr[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:arr)</span><br><span class="line">    cnt[x]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[_,c]:cnt)</span><br><span class="line">    sum+=c*(c<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挖矿</title>
      <link href="/2026/02/03/14.%E6%8C%96%E7%9F%BF/"/>
      <url>/2026/02/03/14.%E6%8C%96%E7%9F%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>小蓝正在数轴上挖矿，数轴上一共有 $n$ 个矿洞，第 $i$ 个矿洞的坐标为 $a_i$。小蓝从 $0$ 出发，每次可以向左或向右移动 $1$ 的距离。当路过一个矿洞时，就会进行挖矿作业，获得 $1$ 单位矿石。但一个矿洞不能被多次挖掘。小蓝想知道在移动距离不超过 $m$ 的前提下，最多能获得多少单位矿石？</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含两个正整数 $n, m$，用一个空格分隔。<br>第二行包含 $n$ 个整数 $a_1, a_2, \cdots, a_n$，相邻整数之间使用一个空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行包含一个整数表示答案。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>Plaintext<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">0 -3 -1 1 2</span><br></pre></td></tr></table></figure></p><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>Plaintext<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>路径：$0 \to -1 \to 0 \to 1 \to 2$，可以对 $0, -1, 1, 2$ 四个矿洞挖掘并获得最多 $4$ 块矿石。<br>_(注：距离计算为 $0 \to -1$ (1) $\to 0$ (1) $\to 1$ (1) $\to 2$ (1)，总距离 4，不超过 $m=4$)_</p><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><p>对于 $20\%$ 的评测用例，$1 \le n \le 10^3$。<br>对于所有评测用例，$1 \le n \le 10^5$，$-10^6 \le a_i \le 10^6$，$1 \le m \le 2 \times 10^6$。</p><p>枚举尽可能往左走和尽可能往右走的情况<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_COORD = <span class="number">2000005</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">arr</span>(<span class="number">4000011</span>,<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> minlocation=<span class="number">2000005</span>,maxlocation=<span class="number">2000005</span>,lmaxvalue=<span class="number">0</span>,rmaxvalue=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        arr[a+MAX_COORD]+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4000010</span>;i++)</span><br><span class="line">        arr[i]+=arr[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((arr[MAX_COORD]-arr[MAX_COORD -i<span class="number">-1</span>]+arr[MAX_COORD+m<span class="number">-2</span>*i]-arr[MAX_COORD])&gt;lmaxvalue)</span><br><span class="line">            lmaxvalue=arr[MAX_COORD]-arr[MAX_COORD -i<span class="number">-1</span>]+arr[MAX_COORD+m<span class="number">-2</span>*i]-arr[MAX_COORD];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">if</span>((arr[MAX_COORD+i]-arr[MAX_COORD<span class="number">-1</span>]+arr[MAX_COORD<span class="number">-1</span>]-arr[MAX_COORD-m<span class="number">+2</span>*i<span class="number">-1</span>])&gt;rmaxvalue)</span><br><span class="line">            rmaxvalue=arr[MAX_COORD+i]-arr[MAX_COORD<span class="number">-1</span>]+arr[MAX_COORD<span class="number">-1</span>]-arr[MAX_COORD-m<span class="number">+2</span>*i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">max</span>(lmaxvalue,rmaxvalue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抓娃娃</title>
      <link href="/2026/02/03/15.%E6%8A%93%E5%A8%83%E5%A8%83/"/>
      <url>/2026/02/03/15.%E6%8A%93%E5%A8%83%E5%A8%83/</url>
      
        <content type="html"><![CDATA[<h3 id="题目名称：抓娃娃"><a href="#题目名称：抓娃娃" class="headerlink" title="题目名称：抓娃娃"></a>题目名称：抓娃娃</h3><p><strong>【问题描述】</strong><br>小明拿了 $n$ 条线段练习抓娃娃。他将所有线段铺在数轴上，第 $i$ 条线段的左端点在 $l_i$，右端点在 $r_i$。<br>小明用 $m$ 个区间去框这些线段，第 $i$ 个区间的范围是 $[L_i, R_i]$。<br>如果一个线段有 <strong>至少一半</strong> 的长度被包含在某个区间内，则将其视为被这个区间框住。<br>请计算出每个区间框住了多少个线段？<br><strong>【输入格式】</strong><br>输入共 $n+m+1$ 行。<br>第一行为两个正整数 $n, m$。<br>后面 $n$ 行，每行两个整数 $l_i, r_i$。<br>后面 $m$ 行，每行两个整数 $L_i, R_i$。<br><strong>【输出格式】</strong><br>输出共 $m$ 行，每行一个整数。<br><strong>【样例输入】</strong><br>Plaintext<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">3 4</span><br><span class="line">1 4</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><br><strong>【样例输出】</strong><br>Plaintext<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p><strong>【评测用例规模与约定】</strong><br>对于 $20\%$ 的数据，保证 $n, m \le 10^3$。<br>对于 $100\%$ 的数据，保证 $n, m \le 10^5$， $l_i &lt; r_i$，$0 &lt; l_i, r_i, L_i, R_i \le 10^6$，$\max{r_i - l_i} \le \min{R_i - L_i}$。</p><p>$\max{r_i - l_i} \le \min{R_i - L_i}$。<br>这个条件说明所有线段的长度都小于或等于区间的长度<br>一个线段一半要被区间包住,说明线段的中点要在区间的范围里面。<br>要计算一个区间里面可以包住多少线段就转化成了有多少线段中点在区间里面。<br>由于l和r取中点可能为小数,我们将范围扩大两倍则中点就为l+r,就不能担心小数问题了。同样要注释咱们包住区间的范围也要扩大两倍<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_COORD = <span class="number">2000005</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">arr</span>(MAX_COORD,<span class="number">0</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">result</span>(MAX_COORD,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        arr[a+b]+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=MAX_COORD;i++)</span><br><span class="line">    arr[i]+=arr[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        result[i]=arr[<span class="number">2</span>*b]-arr[<span class="number">2</span>*a<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    cout&lt;&lt;result[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🚀 本站博客搭建与美化技术文档</title>
      <link href="/2026/02/02/%F0%9F%9A%80%20%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%BE%8E%E5%8C%96%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
      <url>/2026/02/02/%F0%9F%9A%80%20%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%BE%8E%E5%8C%96%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="🚀-本站博客搭建与美化技术文档"><a href="#🚀-本站博客搭建与美化技术文档" class="headerlink" title="🚀 本站博客搭建与美化技术文档"></a>🚀 本站博客搭建与美化技术文档</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>本站基于 <strong>Hexo</strong> 静态博客框架搭建，使用了功能强大的 <strong>Butterfly</strong> 主题。本文档记录了从零开始搭建、配置主题以及进行个性化美化的完整过程，既是对自己折腾过程的记录，也希望能帮助到想搭建类似博客的朋友。</p><h2 id="2-技术栈概览"><a href="#2-技术栈概览" class="headerlink" title="2. 技术栈概览"></a>2. 技术栈概览</h2><ul><li><p><strong>核心框架</strong>: <a href="https://hexo.io/zh-cn/">Hexo</a> (快速、简洁且高效的博客框架)</p></li><li><p><strong>博客主题</strong>: <a href="https://butterfly.js.org/">Butterfly</a> (一款美观且功能丰富的 Hexo 主题)</p></li><li><p><strong>托管平台</strong>: GitHub Pages (免费、稳定的静态网页托管)</p></li><li><p><strong>评论系统</strong>: Giscus (基于 GitHub Discussions 的评论系统)</p></li><li><p><strong>统计工具</strong>: 不蒜子 (Busuanzi)</p></li></ul><h2 id="3-基础环境搭建"><a href="#3-基础环境搭建" class="headerlink" title="3. 基础环境搭建"></a>3. 基础环境搭建</h2><p>参考教程：<a href="https://blog.csdn.net/mjh1667002013/article/details/129064188">【Hexo搭建】免费快速搭建Hexo博客网站并部署上线</a></p><p>我的搭建流程主要分为以下几步：</p><ol><li><p><strong>环境准备</strong>: 安装 Node.js 和 Git，这是 Hexo 运行的基础。</p></li><li><p><strong>初始化博客</strong>: 使用 <code>npm install -g hexo-cli</code> 安装脚手架，并通过 <code>hexo init</code> 生成博客目录。</p></li><li><p><strong>部署设置</strong>: 在 GitHub 创建仓库（<code>用户名.github.io</code>），安装 <code>hexo-deployer-git</code> 插件，实现一键部署 (<code>hexo d</code>)。</p></li></ol><h2 id="4-主题安装与配置"><a href="#4-主题安装与配置" class="headerlink" title="4. 主题安装与配置"></a>4. 主题安装与配置</h2><p>参考教程：<a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">【Hexo】Hexo搭建Butterfly主题并快速美化</a></p><p>为了让博客更美观，我选择了 Butterfly 主题。</p><ul><li><p><strong>安装</strong>: 通过 <code>git clone</code> 下载主题文件到 <code>themes/butterfly</code> 目录。</p></li><li><p><strong>配置策略</strong>: 为了方便后续升级，我采用了“覆盖配置”的方式。即在博客根目录新建 <code>_config.butterfly.yml</code> 文件，专门存放主题的配置项，它会覆盖主题自带的 <code>_config.yml</code>。</p></li></ul><h2 id="5-本站特色功能配置"><a href="#5-本站特色功能配置" class="headerlink" title="5. 本站特色功能配置"></a>5. 本站特色功能配置</h2><p>基于我的 <code>_config.butterfly.yml</code> 文件，本站开启了以下个性化功能：</p><h3 id="5-1-视觉美化"><a href="#5-1-视觉美化" class="headerlink" title="5.1 视觉美化"></a>5.1 视觉美化</h3><ul><li><p><strong>背景特效</strong>: 开启了 <code>canvas_nest</code>（动态线条背景）和 <code>fireworks</code>（鼠标点击烟花特效），增加页面的交互感。</p></li><li><p><strong>看板娘 (Live2D)</strong>: 在页面右下角添加了 Live2D 看板娘挂件，并配置了自定义 CSS 将工具栏调整至左侧，避免遮挡。</p><p>YAML</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 注入的自定义 CSS</span><br><span class="line">#waifu &#123; left: auto; right: 10px; &#125;</span><br><span class="line">#waifu-tool &#123; right: auto; left: -35px; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-2-音乐播放器-APlayer"><a href="#5-2-音乐播放器-APlayer" class="headerlink" title="5.2 音乐播放器 (APlayer)"></a>5.2 音乐播放器 (APlayer)</h3><p>为了让访问者有更好的听觉体验，我集成了 APlayer 全局播放器：</p><ul><li><p><strong>歌单来源</strong>: 网易云音乐 (周杰伦精选集)</p></li><li><p><strong>配置方式</strong>: 通过 <code>inject</code> 在页面底部注入 MetingJS 脚本，实现了迷你模式的左下角播放器。</p><p>HTML</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meting-js   server=&quot;netease&quot;   type=&quot;playlist&quot;   id=&quot;3136952023&quot;   mini=&quot;true&quot;   fixed=&quot;true&quot;&gt;</span><br><span class="line">&lt;/meting-js&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-3-交互与功能"><a href="#5-3-交互与功能" class="headerlink" title="5.3 交互与功能"></a>5.3 交互与功能</h3><ul><li><p><strong>评论系统</strong>: 选用了 <strong>Giscus</strong>，访客可以使用 GitHub 账号登录评论，数据直接存储在 GitHub 仓库的 Discussions 中，安全且无广告。</p></li><li><p><strong>搜索功能</strong>: 开启了 <strong>Local Search</strong>，支持对站内文章的快速检索。</p></li><li><p><strong>数据统计</strong>: 集成了 <strong>不蒜子</strong> 统计，在页脚和侧边栏显示网站的访问量 (PV) 和访客数 (UV)。</p></li></ul><h2 id="6-常用维护命令"><a href="#6-常用维护命令" class="headerlink" title="6. 常用维护命令"></a>6. 常用维护命令</h2><ul><li><p><code>hexo clean</code>: 清除缓存</p></li><li><p><code>hexo g</code>: 生成静态网页 (Generate)</p></li><li><p><code>hexo s</code>: 本地预览 (Server)</p></li><li><p><code>hexo d</code>: 部署到 GitHub (Deploy)</p></li></ul><hr><blockquote><p><strong>致谢</strong>: 感谢博主 [小满@] 提供的详细教程，让我在搭建过程中少走了很多弯路。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>领地选择</title>
      <link href="/2026/02/01/12.%E9%A2%86%E5%9C%B0%E9%80%89%E6%8B%A9/"/>
      <url>/2026/02/01/12.%E9%A2%86%E5%9C%B0%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<p>作为在虚拟世界里统帅千军万马的领袖，小 Z 认为天时、地利、人和三者是缺一不可的。所以，谨慎地选择首都的位置对于小 Z 来说是非常重要的。<br>首都都被认为是一个占地 $C \times C$ 的正方形。小 Z 希望你找到一个合适的位置，使得首都所占领的位置的土地价值总和最高。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h3><ul><li>第一行三个整数 $N, M, C$，表示地图的宽和长以及首都的边长。</li><li>接下来 $N$ 行每行 $M$ 个整数，表示地图上每个地块的价值。价值可能为负数。<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h3></li><li>一行两个整数 $X, Y$，表示首都左上角的坐标。<h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a><strong>输入输出样例</strong></h3></li><li><strong>输入 #1</strong>：<br>  Plaintext  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 2</span><br><span class="line">1 2 3 1</span><br><span class="line">-1 9 0 2</span><br><span class="line">2 0 1 1</span><br></pre></td></tr></table></figure></li><li><strong>输出 #1</strong>：<br>  Plaintext  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure></li></ul><p>二维前缀和<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,M,C,X,Y,MAXVAULE=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;C;</span><br><span class="line">    <span class="type">int</span> arr[N<span class="number">+1</span>][M<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=M;i++)</span><br><span class="line">    arr[<span class="number">0</span>][i]=<span class="number">-2e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=N;i++)</span><br><span class="line">    arr[i][<span class="number">0</span>]=<span class="number">-2e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=M;j++)</span><br><span class="line">        cin&gt;&gt;arr[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=M;j++)</span><br><span class="line">        arr[i][j]+=arr[i][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=M;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;j&lt;=N;j++)</span><br><span class="line">        arr[i][j]+=arr[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=C;j&lt;=M;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j]-arr[i][j-C]-arr[i-C][j]+arr[i+C][j+C]&gt;MAXVAULE)</span><br><span class="line">            &#123;</span><br><span class="line">                MAXVAULE=arr[i][j]-arr[i][j-C]-arr[i-C][j]+arr[i+C][j+C];</span><br><span class="line">                X=i-C<span class="number">+1</span>,Y=j-C<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;X&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光骓者的荣耀</title>
      <link href="/2026/02/01/11.%E5%85%89%E9%AA%93%E8%80%85%E7%9A%84%E8%8D%A3%E8%80%80/"/>
      <url>/2026/02/01/11.%E5%85%89%E9%AA%93%E8%80%85%E7%9A%84%E8%8D%A3%E8%80%80/</url>
      
        <content type="html"><![CDATA[<p>小 K 打下的江山一共有 $n$ 个城市，城市 $i$ 和城市 $i+1$ 有一条双向高速公路连接，走这条路要耗费时间 $a_i$。小 K 为了关心人民生活，决定定期进行走访。他每一次会从 $1$ 号城市到 $n$ 号城市并在经过的城市进行访问。其中终点必须为城市 $n$。<br>不仅如此，他还有一个传送器，传送半径为 $k$，也就是说可以传送到 $i-k$ 和 $i+k$。如果目标城市编号小于 $1$ 则为 $1$，大于 $n$ 则为 $n$。<br>但是他的传送器电量不足，<strong>只能传送一次</strong>，况且由于一些原因，他想尽量快地完成访问，于是就想问交通部部长您最快的时间是多少。<br><strong>注意：</strong> 他可以不访问所有的城市，使用传送器不耗费时间。</p><hr><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a><strong>输入格式</strong></h3><ul><li><strong>两行</strong>：第一行包含两个整数 $n, k$。</li><li><strong>第二行</strong>：包含 $n-1$ 个整数，第 $i$ 个整数表示 $a_i$（即城市 $i$ 到 $i+1$ 之间的耗时）。</li></ul><hr><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a><strong>输出格式</strong></h3><ul><li>输出一个整数，表示从 $1$ 号城市到 $n$ 号城市的最短时间。</li></ul><p>我们想要尽可能的少走,传送的距离尽可能的多<br>用一个数组存储相邻两个城市之间的距离然后计算这个数组的前缀和,计算arr[i+k]-arr[i]的最大值,就可以找到传送的最大距离,以及对应的传送点i<br>用总距离减去这个传送的最大距离就可以得到最短路程<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k,maxdistance=<span class="number">0</span>,maxstation=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;=n<span class="number">-1</span>)</span><br><span class="line">    cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="type">int</span> prefix[n];</span><br><span class="line">    prefix[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    cin&gt;&gt;prefix[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">    prefix[i]+=prefix[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prefix[i+k]-prefix[i]&gt;maxdistance)</span><br><span class="line">        &#123;</span><br><span class="line">            maxdistance=prefix[i+k]-prefix[i];</span><br><span class="line">            maxstation=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxstation&lt;&lt;endl&lt;&lt;prefix[n<span class="number">-1</span>]-maxdistance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接雨水</title>
      <link href="/2026/02/01/13.%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2026/02/01/13.%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<p>题目描述<br>给定 $n$ 个非负整数表示每个柱子的高度，每个柱子的宽度为 1，计算按此排列的柱子，下雨之后能接多少雨水。<br>输入格式</p><ul><li>第一行包含一个整数 $n$，表示柱子的数量。</li><li>接下来的 $n$ 行（或一行内），每行一个非负整数，表示每个位置柱子的高度 $height[i]$。<br>输出格式</li><li>输出一个整数，表示能够接住的雨水总量。</li></ul><p><img src="/5.png" alt="1211"><br>对于每一个单位的我们只需要找到它左边的最大值和右边的最大值,取二者的最小值,再减去这个单位的柱子长度。<br>用前缀最大值数组存储左边最大值,后缀最大值数组存储右边最大值<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,sum=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> arr[n<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="type">int</span> left_max[n<span class="number">+1</span>];</span><br><span class="line">    <span class="type">int</span> right_max[n<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">        left_max[i]=arr[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            left_max[i]=<span class="built_in">max</span>(arr[i],left_max[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==n)</span><br><span class="line">        right_max[i]=arr[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right_max[i]=<span class="built_in">max</span>(arr[i],right_max[i<span class="number">+1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span>(right_max[i],left_max[i])&lt;=arr[i])</span><br><span class="line">        sum+=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        sum+=<span class="built_in">min</span>(right_max[i],left_max[i])-arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/6.png" alt="2222"><br>先找到最高的柱子,对它左边的每个柱子,用它左侧的最大高度减去自身高度,对它右边的每个柱子,<br>用它右侧的最大高度减去自身高度。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="type">int</span> n,sum=<span class="number">0</span>,index=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> arr[n<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="type">int</span> maxhigh=arr[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;maxhigh)</span><br><span class="line">        &#123;</span><br><span class="line">            maxhigh=arr[i];</span><br><span class="line">            index=i;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> maxleft=arr[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;index;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;maxleft)</span><br><span class="line">        maxleft=arr[i];</span><br><span class="line">        sum+=maxleft-arr[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxright=arr[n]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;index;i--) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;maxright)</span><br><span class="line">        maxright=arr[i];</span><br><span class="line">        sum+=maxright-arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>弹珠堆放</title>
      <link href="/2026/01/31/10.%E5%BC%B9%E7%8F%A0%E5%A0%86%E6%94%BE/"/>
      <url>/2026/01/31/10.%E5%BC%B9%E7%8F%A0%E5%A0%86%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<p> 小蓝有 20230610 颗弹珠，想摆成一个金字塔。<br>高度 1：1 颗<br>高度 2：4 颗<br>高度 3：10 颗<br>高度 4：20 颗<br>问：手里的弹珠最多能摆多高？                                                                                                                           <img src="/3.png" alt="2222"><br>观察可知,从上往下,每层数量是以1为首项,公差为以2为首项1为公差的等差数列的等差数列<br>枚举每层数量相加即可<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pre=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> high=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sum&lt;=<span class="number">20230610</span>)&#123;</span><br><span class="line">        sum+=pre;</span><br><span class="line">        high+=<span class="number">1</span>;</span><br><span class="line">        pre=pre+high<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;high<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/4.png" alt="222333"><br>这是每层的数量以及高度为N的总数量和前缀和的关系<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> prefix[<span class="number">1001</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">    prefix[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=<span class="number">1000</span>;j++)</span><br><span class="line">    prefix[j]=prefix[j]+prefix[j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=<span class="number">1000</span>;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        prefix[k]=prefix[k]+prefix[k<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(prefix[k]&gt;<span class="number">20230610</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prefix[k]==<span class="number">20230610</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        cout&lt;&lt;k;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和</title>
      <link href="/2026/01/31/9.%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2026/01/31/9.%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>这是求一个一维数组的前缀和<br>如果我们要计算4-9这个区间的和我们就可以用prefix[9]-prefix[3]得到<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">prefix</span>(n)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i)prefix[i]=prefix[i<span class="number">-1</span>];</span><br><span class="line">prefix[i]+=arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异或的性质 :</p><ol><li>核心定义：相同为 0，不同为 1(从位的角度)</li><li>任何数和 0 异或，结果还是它自己</li><li>A ^(B^C)=(A^B)^ C</li><li>自己异或自己 = 0</li><li>A=B ^ C,两边^ C,A^ C=B<br>求前缀异或<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">prefix</span>(n)</span><br><span class="line">prefix[<span class="number">0</span>]=arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">prefix[i]^=prefix[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果我们要计算4-9这个区间的异或我们就可以用prefix[9]^ prefix[3]</li></ol><p>二维前缀和(在二维矩阵中求任意子矩阵的和)<br><img src="/algo_map.png" alt="算法前缀和图解"><br>比如12就代表的是左上角2 * 2区域的和<br><img src="/1111.png" alt="111111"></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 前缀和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举算法入门</title>
      <link href="/2026/01/27/0.%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2026/01/27/0.%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在某个可能的解的集合中,按某个顺序依次检索元素,用题目给定的条件进行校验和计算。<br>是否存在,找到第一个,全部都,全部都不。</p><p>原数组中是否存在子数组？(元素无需连续，但需保持相对顺序一致)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">templata&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">subMatch</span><span class="params">(<span class="type">const</span> T&amp;arr,<span class="type">const</span> T&amp;target)</span></span>&#123;</span><br><span class="line"><span class="type">size_t</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;elem : arr)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(elem==target[idx])</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(++idx == target.<span class="built_in">size</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>寻找第K小的素数?<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> idx=<span class="number">1</span>;;idx++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isPrime</span>(idx))</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(cnt==k)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;idx;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="枚举的优化-裁剪枚举集"><a href="#枚举的优化-裁剪枚举集" class="headerlink" title="枚举的优化:裁剪枚举集"></a>枚举的优化:裁剪枚举集</h2><p>判断一个数是否为素数?<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n%i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>根据数学特性可以缩小枚举范围<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n%i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按位枚举:<br> 比如枚举十进制数1234的每一位<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="type">int</span> dight = x % <span class="number">10</span>;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">x /=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 对于将十进制整数 <code>x</code> 转换为 <code>base</code> 进制的各位数字,把10改为对应的进制数<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr1;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="type">int</span> dight = x % base;</span><br><span class="line">arr<span class="number">1.</span><span class="built_in">push_back</span>(dight);</span><br><span class="line">x /=base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将 <code>base</code> 进制的逆序数字转换回十进制整数<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=arr<span class="number">1.</span><span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">  x = x * base +arr1[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好数</title>
      <link href="/2026/01/27/1.%E5%A5%BD%E6%95%B0/"/>
      <url>/2026/01/27/1.%E5%A5%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>一个整数如果按从低位到高位的顺序，奇数位（个位、百位、万位 · · · ）上的数字是奇数，偶数位（十位、千位、十万位 · · · ）上的数字是偶数，我们就称之为“好数”。给定一个正整数 N，请计算从 1 到 N 一共有多少个好数。</p><p>我的思路就是利用<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line"><span class="type">int</span> dight = x % <span class="number">10</span>;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">x /=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>取它的每一位判断,但我怎么可以确定每一位是对应奇数位还是偶数位了?我无法确定,于是我就想到一种简单粗暴的方式,把从低位到高位的每一位取出来然后存放在数组中,用两个循环分别遍历数组的奇数位和偶数位,判断每一位是不是符合要求。于是就有了下面的代码。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsHaoShu</span><span class="params">(<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; arr1;</span><br><span class="line">   <span class="type">int</span> n;</span><br><span class="line">   <span class="keyword">while</span>(N)&#123;</span><br><span class="line">    n=N%<span class="number">10</span>;</span><br><span class="line">    arr<span class="number">1.</span><span class="built_in">push_back</span>(n);</span><br><span class="line">    N/=<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> flag1=<span class="number">1</span>,flag2=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=arr<span class="number">1.</span><span class="built_in">size</span>()<span class="number">-1</span>;i+=<span class="number">2</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr1[i]%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag1=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=arr<span class="number">1.</span><span class="built_in">size</span>()<span class="number">-1</span>;j+=<span class="number">2</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr1[j]%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">            flag2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(flag1 &amp;&amp; flag2)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsHaoShu</span>(k))</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>简单粗暴,时间复杂度为O(NlogN)<br>后来了就看到一种每次在while循环里面可以判断我所判断的这一位就是是要满足偶数位性质还是奇数位性质。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> index=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> dight=x%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(dight % <span class="number">2</span> != index % <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>很巧妙的运用到了一个index，它模2是一个1，0，1，0的循环序列,刚好对应奇数位为奇数模2余1,偶数位为偶数模2余0。还有几种写法,就是把index++改为index=1-index或者index ^=1。<br>优化后的代码为<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsHaoShu</span><span class="params">(<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> dight=N%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(dight % <span class="number">2</span>!=index % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        N /=<span class="number">10</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,count=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsHaoShu</span>(i))</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>幸运数</title>
      <link href="/2026/01/27/2.%E5%B9%B8%E8%BF%90%E6%95%B0/"/>
      <url>/2026/01/27/2.%E5%B9%B8%E8%BF%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>小蓝认为如果一个数含有偶数个数位，并且前面一半的数位之和等于后面 一半的数位之和，则这个数是他的幸运数字。例如2314是一个幸运数字，因为 它有4个数位，并且2+3=1+4。现在请你帮他计算从1至100000000之间 共有多少个不同的幸运数字？</p><p>这道题思路比较简单,一个数对10取对数然后向上取整可以得到它的位数,对于位数为偶数的数,按位枚举,前一半相加后一半相加。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsLucky</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> m=<span class="built_in">log10</span>(n)<span class="number">+1</span>,sum1=<span class="number">0</span>,sum2=<span class="number">0</span>,index=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(m%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">while</span>(n)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">int</span> dight=n%<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">if</span>(index&gt;m/<span class="number">2</span>)</span><br><span class="line">      sum2+=dight;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      sum1+=dight;</span><br><span class="line">      n/=<span class="number">10</span>;</span><br><span class="line">      index++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum1==sum2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100000000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsLucky</span>(i))</span><br><span class="line">        sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡片</title>
      <link href="/2026/01/27/3.%E5%8D%A1%E7%89%87/"/>
      <url>/2026/01/27/3.%E5%8D%A1%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>小蓝有很多数字卡片，每张卡片上标有 0到9 中的一个数字。<br>他想用这些卡片从 1 开始拼出连续的正整数，每拼一个数，就把用到的卡片保存起来，之后不能再用这些卡片拼其他数。<br>例如，如果小蓝手里有 30 张卡片，每个数字 0到9 各 3 张，他可以拼出 1到10，但是拼 11 时，数字 1 的卡片已经不够用了。<br>现在，小蓝手里有每个数字 0到9 的卡片各 2021 张（总共 20210 张），问他能够从 1 拼到的最大连续整数是多少？<br>这道题的思路也很简单,咱们准备一个十个空间大小的数组vec[10],都存储2021,代表0~9的卡片都有2021张,遍历从1开始的数,我们将它逐位分解,对于分解出的每一位x,vec[x]—，直到某个数分解出的某位i,vec[i]=0时,说明没有卡片去给它组成这个数了，那么答案就是这个数的上一个数。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>,<span class="number">2021</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> re=i;</span><br><span class="line">        <span class="keyword">while</span>(re)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> index=re%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(vec[index]==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">            vec[index]--;</span><br><span class="line">            re/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">work</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小球反弹</title>
      <link href="/2026/01/27/5.%E5%B0%8F%E7%90%83%E5%8F%8D%E5%BC%B9/"/>
      <url>/2026/01/27/5.%E5%B0%8F%E7%90%83%E5%8F%8D%E5%BC%B9/</url>
      
        <content type="html"><![CDATA[<p>有一长方形，长为 343720 单位长度，宽为 233333 单位长度。 在其内部左上角顶点有一小球 (无视其体积)，其初速度如图所示且保持运动速率不变，分解到长宽两个方向上的速率之比为 dx:dy=15:17。 小球碰到长方形的边框时会发生反弹，每次反弹的入射角与反射角相等，因此小球会改变方向且保持速率不变（如果小球刚好射向角落，则按入射方向原路返回）。从小球出发到其第一次回到左上角顶点这段时间里，小球运动的路程为多少单位长度？答案四舍五入保留两位小数。<br>![[Pasted image 20260119121851.png]]<br>可以把小球每次反弹都投影到一个镜像世界里面<br>假设lenth=343720,wide=233333<br>![[未命名绘图.drawio.png]]<br>我们可以观察到原点在镜像世界中的投影点满足x为2 <em> lenth的整数倍数,y为2 </em> wide的整数倍数。小球每时每刻沿直线运动在x和y轴上的分量都满足15:17。<br>枚举t从1到正无穷,使得小球在t时刻的x和y运动分量满足到达原点所要求的条件。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx=<span class="number">15</span>,dy=<span class="number">17</span>,wide=<span class="number">2</span>*<span class="number">233333</span>,lenth=<span class="number">2</span>*<span class="number">343720</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t*dx%lenth==<span class="number">0</span>&amp;&amp;t*dy%wide==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line">            cout&lt;&lt;fixed&lt;&lt;<span class="built_in">hypot</span>(t*dx,t*dy);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找2020</title>
      <link href="/2026/01/27/4.%E5%AF%BB%E6%89%BE2020/"/>
      <url>/2026/01/27/4.%E5%AF%BB%E6%89%BE2020/</url>
      
        <content type="html"><![CDATA[<p>给定一个 n×n 的二维数组，数组中的每个元素都是 <code>0</code> 或 <code>2</code>。请你统计数组中<strong>连续的四个元素</strong>恰好组成 <code>2020</code> 的序列个数。<br>连续序列的方向限定为以下 <strong>4 种</strong>：</p><ol><li><strong>水平向右</strong>：同一行中，从左到右连续 4 个元素</li><li><strong>竖直向下</strong>：同一列中，从上到下连续 4 个元素</li><li><strong>主对角线向下</strong>：左上到右下方向，连续 4 个元素</li><li><strong>副对角线向下</strong>：右上到左下方向，连续 4 个元素<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3></li><li>第一行输入一个整数 n（4≤n≤1000），表示二维数组的行数和列数</li><li>接下来 n 行，每行输入一个长度为 n 的字符串，字符串仅由 <code>0</code> 和 <code>2</code> 组成<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3>输出一个整数，表示满足条件的 <code>2020</code> 序列的总个数</li></ol><p>这道题目刚开始我理解的意思时,一个序列的四个元素只能用一次,下一次寻找的序列的元素要是没有被选中过的,这种想法应该有很多不一样的答案。<br>这道题的意思其实时找出所有可能不考虑是否构成序列的元素是否被用过。<br>我们只需要遍历每一个元素,看它在这四种序列方向上是否可以构成一个2020序列。在遍历时可以简化枚举次数。<br>比如一个n*n的二维数组,(i,j)处的数要构成横向的2020则必须要j+3&lt;=n，同理要构成竖向的2020要满足i+3&lt;=n,构成主对角线向下的2020则必须要满足i+3&lt;=n&amp;&amp;j+3&lt;=n，构成副对角线向下的2020则必须要满足i+3&lt;=n&amp;&amp;j-3&gt;=1<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,cnt=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">arr</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string a;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        arr[i][j]=a[j<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">if</span>(j<span class="number">+3</span>&lt;=n&amp;&amp;arr[i][j]==<span class="number">2</span>&amp;&amp;arr[i][j<span class="number">+1</span>]==<span class="number">0</span>&amp;&amp;arr[i][j<span class="number">+2</span>]==<span class="number">2</span>&amp;&amp;arr[i][j<span class="number">+3</span>]==<span class="number">0</span>)</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">+3</span>&lt;=n&amp;&amp;arr[i][j]==<span class="number">2</span>&amp;&amp;arr[i<span class="number">+1</span>][j]==<span class="number">0</span>&amp;&amp;arr[i<span class="number">+2</span>][j]==<span class="number">2</span>&amp;&amp;arr[i<span class="number">+3</span>][j]==<span class="number">0</span>)</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">+3</span>&lt;=n&amp;&amp;j<span class="number">+3</span>&lt;=n&amp;&amp;arr[i][j]==<span class="number">2</span>&amp;&amp;arr[i<span class="number">+1</span>][j<span class="number">+1</span>]==<span class="number">0</span>&amp;&amp;arr[i<span class="number">+2</span>][j<span class="number">+2</span>]==<span class="number">2</span>&amp;&amp;arr[i<span class="number">+3</span>][j<span class="number">+3</span>]==<span class="number">0</span>)</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(j<span class="number">-3</span>&gt;=<span class="number">1</span>&amp;&amp;i<span class="number">+3</span>&lt;=n&amp;&amp;arr[i][j]==<span class="number">2</span>&amp;&amp;arr[i<span class="number">+1</span>][j<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;arr[i<span class="number">+2</span>][j<span class="number">-2</span>]==<span class="number">2</span>&amp;&amp;arr[i<span class="number">+3</span>][j<span class="number">-3</span>]==<span class="number">0</span>)</span><br><span class="line">            cnt++;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特殊日期</title>
      <link href="/2026/01/27/6.%E7%89%B9%E6%AE%8A%E6%97%A5%E6%9C%9F/"/>
      <url>/2026/01/27/6.%E7%89%B9%E6%AE%8A%E6%97%A5%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>记一个日期为 yy 年 mm 月 dd 日。统计从 2000 年 1 月 1 日（含）到 2000000 年 1 月 1 日（含），有多少个日期满足年份 yy 是月份 mm 的倍数，同时也是 dd 的倍数。<br>当年份是 4 的倍数而不是 100 的倍数或者年份是 400 的倍数时，这一年是闰年，其他的年份都不是闰年。<br>遍历每一年的每一个月的每一天。二月份天数最为特殊,闰年29，平年28<br>我们可以先创建一个数组int  MonthDay[12]={31,28,31,30,31,30,31,31,30,31,30,31}<br>在遍历年的循环中设置一个flag=((i%4 == 0 &amp;&amp; i%100!=0) || (i%400 == 0))<br>更新MonthDay[1]=28+flag<br>这样就解决二月份天数问题<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> MonthDay[<span class="number">12</span>]=&#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2000</span>;i&lt;=<span class="number">1999999</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> IsLeapYear=((i%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; i%<span class="number">100</span>!=<span class="number">0</span>) || (i%<span class="number">400</span>==<span class="number">0</span>));</span><br><span class="line">        MonthDay[<span class="number">1</span>]=<span class="number">28</span>+IsLeapYear;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">12</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=MonthDay[j<span class="number">-1</span>];k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i%j==<span class="number">0</span>&amp;&amp;i%k==<span class="number">0</span>)</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神奇闹钟</title>
      <link href="/2026/01/27/8.%E7%A5%9E%E5%A5%87%E9%97%B9%E9%92%9F/"/>
      <url>/2026/01/27/8.%E7%A5%9E%E5%A5%87%E9%97%B9%E9%92%9F/</url>
      
        <content type="html"><![CDATA[<p>小蓝发现了一个神奇的闹钟, 从纪元时间（1970 年 1月 1日 00: 00: 00）开始, 每经过 x 分钟, 这个闹钟便会触发一次闹铃 (纪元时间也会响铃). 这引起了小蓝的兴趣, 他想要好好研究下这个闹钟.<br>对于给出的时间一个格式为 yyyy-MM-dd HH:mm:ss 的时间, 小蓝想要知道在这个时间点之前(包含这个时间点)最近的一次闹铃是什么时间?<br>注意,你不必考虑时区问题。<br>输入格式<br>输入的第一行包含一个整数 T , 表示每次输入包含 T 组数据.<br>接下来依次描述 T 组数据.<br>每组数据一行。包含一个时间（格式为 yyyy-MM-dd HH:mm:ss）和一个整数 x ，其中 x表示闹铃时间间隔（单位为分钟）.<br>输出格式<br>输出 T 行. 每行包含一个时间（格式为 yyyy-MM-dd HH:mm:ss），依次表示每组数据的答案。</p><p>首先把从1970年到输入时间之间的秒数long long res算出来,再计算出可以触发闹铃的次数n= (res / (x <em> 60)) ,从而计算出从1970年开始到最后一次闹铃之间的秒数res= (res / (x</em>60)) <em> x </em> 60,再把这个秒数转化为题目要求的时间格式<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gettimestamp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d,<span class="type">int</span> e,<span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> IsLeapYear=((a%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; a%<span class="number">100</span>!=<span class="number">0</span>) || (a%<span class="number">400</span>==<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> MonthDay[<span class="number">12</span>]=&#123;<span class="number">31</span>,<span class="number">28</span>+IsLeapYear,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> commonyear=<span class="number">365</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> leapyear=<span class="number">366</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1970</span>;i&lt;a;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; i%<span class="number">100</span>!=<span class="number">0</span>) || (i%<span class="number">400</span>==<span class="number">0</span>))</span><br><span class="line">        res+=leapyear;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        res+=commonyear;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;b;j++)</span><br><span class="line">    res+=MonthDay[j<span class="number">-1</span>]*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;c;k++)</span><br><span class="line">    res+=<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=d;l++)</span><br><span class="line">    res+=<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">1</span>;m&lt;=e;m++)</span><br><span class="line">    res+=<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">1</span>;n&lt;=f;n++)</span><br><span class="line">    res+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintTime</span><span class="params">(<span class="type">long</span> <span class="type">long</span> res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> year=<span class="number">1970</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> secyear=(<span class="number">365</span>+((year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span>) || (year%<span class="number">400</span>==<span class="number">0</span>)))*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;=secyear)</span><br><span class="line">        &#123;</span><br><span class="line">            year++;</span><br><span class="line">            res-=secyear;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> MonthDay[<span class="number">12</span>]=&#123;<span class="number">31</span>,<span class="number">28</span>+((year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span>) || (year%<span class="number">400</span>==<span class="number">0</span>)),<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">    <span class="type">int</span> month=<span class="number">1</span>,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;=MonthDay[i]*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res-=MonthDay[i]*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            month+=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> day=<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;=<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res-=<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            day+=j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> hour = res/<span class="number">3600</span>; res%= <span class="number">3600</span>;</span><br><span class="line">    <span class="type">int</span> minute = res/<span class="number">60</span>; res%= <span class="number">60</span>;</span><br><span class="line">    <span class="type">int</span> second = res;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%04d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, year, month, day, hour, minute, second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=T;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c,d,e,f,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d-%d-%d %d:%d:%d %d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,&amp;x);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res=<span class="built_in">gettimestamp</span>(a,b,c,d,e,f);</span><br><span class="line">        res= (res / (x*<span class="number">60</span>)) * x * <span class="number">60</span>;</span><br><span class="line">        <span class="built_in">PrintTime</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期统计</title>
      <link href="/2026/01/27/7.%E6%97%A5%E6%9C%9F%E7%BB%9F%E8%AE%A1/"/>
      <url>/2026/01/27/7.%E6%97%A5%E6%9C%9F%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>小蓝现在有一个长度为100的数组，数组中的每个元素的值都在0 到9 的范围之内。数组中的元素从左至右如下所示<br>5 6 8 6 9 1 6 1 2 4 9 1 9 8 2 3 6 4 7 7 5 9 5 0 3 8 7 5 8 1 5 8 6 1 8 3 0 3 7 9 2 7 0 5 8 8 5 7 0 9 9 1 9 4 4 6 8 6 3 3 8 5 1 6 3 4 6 7 0 7 8 2 7 6 8 9 5 6 5 6 1 4 0 1 0 0 9 4 8 0 9 1 2 8 5 0 2 5 3 3<br>现在他想要从这个数组中寻找一些满足以下条件的子序列：<br>子序列的长度为8；<br>这个子序列可以按照下标顺序组成一个yyyymmdd 格式的日期，并且要求这个日期是2023 年中的某一天的日期，例如20230902，20231223。yyyy 表示年份，mm 表示月份，dd 表示天数，当月份或者天数的长度只有一位时需要一个前导零补充。<br>请你帮小蓝计算下按上述条件一共能找到多少个不同的2023 年的日期。<br>对于相同的日期你只需要统计一次即可。</p><p>枚举2023年的每一天进行子序列的匹配<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">daysmatch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;numbers,vector&lt;<span class="type">int</span>&gt;&amp;match)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">99</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(numbers[i]==match[idx])</span><br><span class="line">      idx++;</span><br><span class="line">      <span class="keyword">if</span>(idx==match.<span class="built_in">size</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> vector &lt;<span class="type">int</span>&gt; numbers=&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>,</span><br><span class="line"> <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>,</span><br><span class="line"> <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"> <span class="number">8</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> MonthDay[<span class="number">12</span>]=&#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> month=<span class="number">1</span>;month&lt;=<span class="number">12</span>;month++)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> day=<span class="number">1</span>;day&lt;=MonthDay[month<span class="number">-1</span>];day++)</span><br><span class="line">   &#123;</span><br><span class="line">      vector &lt;<span class="type">int</span>&gt; match=&#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,month/<span class="number">10</span>,month%<span class="number">10</span>,day/<span class="number">10</span>,day%<span class="number">10</span>&#125;;</span><br><span class="line">      cnt+=<span class="built_in">daysmatch</span>(numbers,match);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> cout&lt;&lt;cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 枚举 </category>
          
          <category> 枚举算法题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
